<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/03/TCP-IP初探/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/03/TCP-IP初探/" itemprop="url">TCP/IP初探</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-03T20:08:14+08:00">
                2018-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="TCP-IP初探"><a href="#TCP-IP初探" class="headerlink" title="TCP_IP初探"></a>TCP_IP初探</h1><p><strong>TCP/IP</strong>的全称是<strong>Transmission Control Protocol/Internet Protocol</strong>，中译名为<strong>传输控制协议/因特网互联协议</strong>，又名<strong>网络通讯协议</strong>，是<strong>Internet</strong>最基本的协议、<strong>Internet</strong>国际互联网络的基础，由<strong>网络层</strong>的<strong>IP协议</strong>和<strong>传输层</strong>的<strong>TCP协议</strong>组成。<strong>TCP/IP</strong>定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了<strong>4层</strong>的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</p>
<p>通俗而言：<strong>TCP</strong>负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而<strong>IP</strong>是给因特网的每一台联网设备规定一个地址。</p>
<p><strong>TCP/IP</strong>是一组通信协议的代名词，是由一系列协议组成的协议簇。它本身指两个协议集：</p>
<ul>
<li>TCP 传输控制协议</li>
<li>IP    互联网络协议</li>
</ul>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/%E5%8D%8F%E8%AE%AE/_v_images/_1525345982_3895.png" alt=""></p>
<p>当数据在网路中传输的时候，会依次进过每一层，最终呈现给用户</p>
<h2 id="TCP-IP体系和协议栈之间的关系"><a href="#TCP-IP体系和协议栈之间的关系" class="headerlink" title="TCP/IP体系和协议栈之间的关系"></a>TCP/IP体系和协议栈之间的关系</h2><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/%E5%8D%8F%E8%AE%AE/_v_images/_1525346196_27548.png" alt=""></p>
<p>我们可以看出，我们熟知的<strong>DNS</strong>，<strong>FTP</strong>等等协议，都是在应用层上的协议，下面我用FTP做例子讲解这个<strong>从上到下</strong>又<strong>从下到上</strong>的过程</p>
<h3 id="基于TCP-IP的文件传输协议-FTP"><a href="#基于TCP-IP的文件传输协议-FTP" class="headerlink" title="基于TCP/IP的文件传输协议(FTP)"></a>基于TCP/IP的文件传输协议(FTP)</h3><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/%E5%8D%8F%E8%AE%AE/_v_images/_1525346229_31122.png" alt=""></p>
<p>原始数据在应用层加上了一个<strong>FTP头</strong>之后，在传输层加上了<strong>TCP头</strong>，依次类推，到达目的之后，又<strong>反方向</strong>脱去数据头，最终呈现原始的数据</p>
<h2 id="数据链路层协议"><a href="#数据链路层协议" class="headerlink" title="数据链路层协议"></a>数据链路层协议</h2><p>这里我们稍微了解一下数据链路层协议</p>
<h3 id="SLIP"><a href="#SLIP" class="headerlink" title="SLIP"></a>SLIP</h3><p>全称是<strong>Serial Line IP</strong>，它是一种在串行线路上对<strong>IP</strong>数据报进行封装的简单形式 </p>
<h3 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h3><p>点对点协议修改了<strong>SLIP</strong>协议中的所有缺陷，与<strong>SLIP</strong>类似，<strong>PPP</strong>经常用于低速的串行链路</p>
<h2 id="网络层IP协议"><a href="#网络层IP协议" class="headerlink" title="网络层IP协议"></a>网络层IP协议</h2><p>网际协议(<strong>IP</strong>)主要负责在主机之间寻址和选择数据包的路由，<strong>IP</strong>协议不含错误恢复的编码，属于不可靠的协议</p>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p><strong>MAC</strong>地址是网路设备在出厂之前由厂家写入到硬件中的一个地址</p>
<p>当我们的设备接入网络之后，计算机会使用<strong>ARP协议</strong>来建立<strong>IP地址</strong>和<strong>MAC地址</strong>的映射表</p>
<p>为什么讲这个，<strong>ARP攻击</strong>的原理就是从这里引伸出来的</p>
<h2 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h2><p><strong>IP地址</strong>划分为<strong>A、B、C</strong>3类</p>
<p>由<strong>InternetNIC</strong>在全球范围内统一分配，<strong>D、E</strong>类为特殊地址（组播和广播）</p>
<h3 id="A类IP地址"><a href="#A类IP地址" class="headerlink" title="A类IP地址"></a>A类IP地址</h3><p>一个<strong>A类IP地址</strong>由<strong>1字节</strong>的网络地址和<strong>3字节</strong>主机地址组成，网络地址的最高位必须是0</p>
<p>地址范围从<strong>0.0.0.0</strong> 到<strong>127.255.255.255</strong></p>
<p>可用的<strong>A类网络</strong>有<strong>126</strong>个，每个网络能容纳<strong>1亿多</strong>个主机</p>
<p>A类的<strong>私有IP</strong>为</p>
<p><strong>10.0.0.0</strong> 到 <strong>10.255.255.255</strong></p>
<h3 id="B类IP地址"><a href="#B类IP地址" class="headerlink" title="B类IP地址"></a>B类IP地址</h3><p>一个<strong>B类IP地址</strong>由<strong>2个字节</strong>的网络地址和<strong>2个字节</strong>的主机地址组成，网络地址的最高位必须是10</p>
<p>地址范围从<strong>128.0.0.0</strong>到<strong>191.255.255.255</strong></p>
<p>可用的<strong>B类网络</strong>有<strong>16382</strong>个，每个网络能容纳<strong>6万多</strong>个主机 。 </p>
<p>B类的<strong>私有IP</strong>为</p>
<p><strong>172.16.0.0 </strong>到 <strong>172.31.255.255</strong></p>
<h3 id="C类IP地址"><a href="#C类IP地址" class="headerlink" title="C类IP地址"></a>C类IP地址</h3><p>一个<strong>C类IP地址</strong>由<strong>3字节</strong>的网络地址和<strong>1字节</strong>的主机地址组成，网络地址的最高位必须是110</p>
<p>范围从<strong>192.0.0.0</strong>到<strong>223.255.255.255</strong>，<strong>C类网络</strong>可达<strong>209万余</strong>个，每个网络能容纳<strong>254</strong>个主机。 </p>
<p>C类的<strong>私有IP</strong>为</p>
<p><strong>192.168.0.0 </strong>到 <strong>192.168.255.255</strong></p>
<p>现在我们大多数的<strong>家庭路由器</strong>都是工作在这个段里面</p>
<p>那么一个网络设备是如何能被其他网络设备发现的呢？</p>
<p>对于这么几个地址，做到<strong>知道</strong>并能<strong>区别</strong></p>
<h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p><strong>ARP</strong>把基于<strong>TCP/IP</strong>软件使用的<strong>IP地址</strong>解析成局域网硬件使用的媒体访问控制(<strong>MAC地址</strong>)地址</p>
<h2 id="互连网控制报文协议ICMP"><a href="#互连网控制报文协议ICMP" class="headerlink" title="互连网控制报文协议ICMP"></a>互连网控制报文协议ICMP</h2><p><strong>ICMP</strong>传递差错报文以及其他需要注意的信息</p>
<p><strong>ICMP</strong>报文通常被网络层或更高层协议(<strong>TCP</strong>或<strong>UDP</strong>)使用，一些<strong>ICMP</strong>报文把差错报文返回给用户进程</p>
<p><strong>ICMP</strong>用来传送一些关于网络和主机的控制信息，如目标主机是不可到达的、路由的重定向等</p>
<p>常用的<strong>ping</strong>命令就是使用了<strong>ICMP</strong>协议，<strong>ICMP</strong>不为数据提供错误控制服务，只是报告数据出错并不再传送错误的数据，并在<strong>IP数据报</strong>的生存期过后将期抛弃</p>
<h2 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h2><p>传输层包括两个协议：</p>
<p>第一个是<strong>TCP协议</strong>，即传输控制协议，是一个可靠的、面向连接的协议</p>
<p>第二个是<strong>UDP协议</strong>，它采用无连接的方式，不管发送的数据包是否到达目的主机，数据包是否出错，收到数据包的主机也不会告诉发送方是否正确收到了数据，它的可靠性是由上层协议来保障的</p>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>传输控制协议<strong>TCP</strong>将数据分成数据报，用能够到达目的地的路径信息连行包装,接收端则将这些数据进行重组。它提供可靠的、面向连接的数据报传递服务</p>
<h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>用户数据报协议<strong>UDP</strong>是无连接的服务，在无连接服务的情况下，两个实体之间的通信不需先建立好一个连接，因此其下层的有关资源不需要事先进行预定保留，这些资源将在数据传输时动态地进行分配</p>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p><strong>传输层</strong>就是通过<strong>协议端口</strong>(<strong>protocol port</strong>，简称<strong>端口</strong>)与<strong>应用层</strong>的应用程序进行信息交互的，应用层各种用户进程通过相应的端口与传输层实体进行信息交互</p>
<p><strong>端口</strong>实际上是一个<strong>16bit</strong>长的地址，范围可以从<strong>0</strong>至<strong>65535</strong></p>
<p>将<strong>0</strong>至<strong>1023</strong>端口号称为<strong>熟知端口</strong>(<strong>Well-Known Port</strong>)，其余<strong>1024</strong>至<strong>65535</strong>端口号称为<strong>一般端口</strong>或<strong>动态连接端口</strong>(<strong>Registered/Dynamic</strong>)</p>
<p>在数据传输过程中，应用层中的各种不同的服务器进程不断地检测分配给它们的端口，以便发现是否有某个应用进程要与它通信。</p>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/%E5%8D%8F%E8%AE%AE/_v_images/_1525348817_4797.png" alt=""></p>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/%E5%8D%8F%E8%AE%AE/_v_images/_1525348832_13378.png" alt=""></p>
<p>TCP/IP是全双工的，每个方向都必须单独进行关闭。</p>
<p>上图中1和3没有先后顺序，在2和3之间服务器仍可以向客户端发送数据，客户端此时只能接收数据，而不能发送数据。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/03/访问控制模型二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/03/访问控制模型二/" itemprop="url">访问控制模型二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-03T18:47:59+08:00">
                2018-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="访问控制模型二"><a href="#访问控制模型二" class="headerlink" title="访问控制模型二"></a>访问控制模型二</h1><h2 id="访问控制应用类型"><a href="#访问控制应用类型" class="headerlink" title="访问控制应用类型"></a>访问控制应用类型</h2><p>根据应用环境的不同，访问控制主要有以下三种：</p>
<ul>
<li>网络访问控制</li>
<li>主机、操作系统访问控制</li>
<li>应用程序访问控制</li>
</ul>
<h3 id="网络访问控制"><a href="#网络访问控制" class="headerlink" title="网络访问控制"></a>网络访问控制</h3><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525323472_18267.png" alt=""></p>
<p>访问控制机制应用在网络安全环境中，主要是限制用户可以建立什么样的连接以及通过网络传输什么样的数据，这就是传统的网络防火墙。防火墙作为网络边界阻塞点来过滤网络会话和数据传输。根据防火墙的性能和功能，这种控制可以达到不同的级别。</p>
<p>防火墙可实现以下几类访问控制：</p>
<ul>
<li><p>连接控制，控制哪些应用程序终结点之间可建立连接。例如，防火墙可控制内部的某些用户可以发起对外部<code>WEB</code>站点间的连接。</p>
</li>
<li><p>协议控制，控制用户通过一个应用程序可以进行什么操作，例如，防火墙可以允许用户浏览一个页面，同时拒绝用户在非信任的服务器上发布数据。</p>
</li>
<li><p>数据控制，防火墙可以控制应用数据流的通过。如防火墙可以阻塞邮件附件中的病毒。</p>
</li>
</ul>
<p>防火墙实现访问控制的尺度依赖于它所能实现的技术。</p>
<h3 id="主机-操作系统访问控制"><a href="#主机-操作系统访问控制" class="headerlink" title="主机/操作系统访问控制"></a>主机/操作系统访问控制</h3><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525323634_20102.png" alt=""></p>
<p>目前主流的操作系统均提供不同级别的访问控制功能。通常，操作系统借助访问控制机制来限制对文件及系统设备的访问。</p>
<p>例如：<code>Windows NT/2000</code>操作系统应用访问控制列表来对本地文件进行保护，访问控制列表指定某个用户可以读、写或执行某个文件。文件的所有者可以改变该文件访问控制列表的属性。</p>
<h3 id="应用程序访问控制"><a href="#应用程序访问控制" class="headerlink" title="应用程序访问控制"></a>应用程序访问控制</h3><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525323752_20213.png" alt=""></p>
<p>访问控制往往嵌入应用程序（或中间件）中以提供更细粒度的数据访问控制。当访问控制需要基于数据记录或更小的数据单元实现时，应用程序将提供其内置的访问控制模型。</p>
<p>例如，大多数数据库（如<code>Oracle</code>）都提供独立于操作系统的访问控制机制，<code>Oracle</code>使用其内部用户数据库，且数据库中的每个表都有自己的访问控制策略来支配对其记录的访问。</p>
<p>另外比较典型的例子是电子商务应用程序，该程序认证用户的身份并将其置于特定的组中，这些组对应用程序中的某一部分数据拥有访问权限。</p>
<h2 id="BLP-保密模型"><a href="#BLP-保密模型" class="headerlink" title="BLP 保密模型"></a>BLP 保密模型</h2><p><code>Bell-LaPadula</code>保密性模型是第一个能够提供分级别数据机密性保障的安全策略模型（多级安全）。</p>
<p>1973年，<code>David Bell</code>和<code>Len LaPadula</code>提出了第一个正式的安全模型，该模型基于强制访问控制系统，以敏感度来划分资源的安全级别。将数据划分为多安全级别与敏感度的系统称之为多级安全系统</p>
<p><code>Bell-LaPadula</code> (<code>BLP</code>) 安全模型对主体和客体按照强制访问控制系统的哲学进行分类，这种分类方法一般应用于军事用途。</p>
<p>数据和用户被划分为以下安全等级</p>
<ul>
<li>公开（Unclassified）</li>
<li>受限（Restricted）</li>
<li>秘密（Confidential）</li>
<li>机密（Secret）</li>
<li>高密（Top Secret）</li>
</ul>
<p><code>BLP 保密模型</code>基于两种规则来保障数据的机秘度与敏感度：</p>
<ul>
<li>上读(NRU) , 主体不可读安全级别高于它的数据</li>
<li>下写(NWD) , 主体不可写安全级别低于它的数据</li>
</ul>
<p>　　直接来讲，要考虑数据的保秘性. 例如.假如一个用户，他的安全级别为”高密”，想要访问安全级别为”秘密”的文档，他将能够成功读取该文件，但不能写入；而安全级别为”秘密”的用户访问安全级别为”高密”的文档，则会读取失败，但他能够写入。这样，文档的保秘性就得到了保障。</p>
<p>　　另外，目前不能在原有操作系统中直接进行安全分级。也就是说，在解决其易用性与功能单一性之前，<code>BLP模型</code>不能直接用于商业系统。</p>
<p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525323995_20744.png" alt=""></p>
<p>图为一个用户和资源安全分级的例子。BLP模型允许用户读取安全级别比他低的资源；相反地，写入对象的安全级别只能高于用户级别。简言之，信息系统是一个由低到高的层次化结构。</p>
<p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525324036_12570.png" alt=""></p>
<p>图示例在通讯过程中如何体现<code>BLP模型</code>思想，尽管这种应用在<code>BLP模型</code>的实际应用中并不多见。当企业的两个分支网络要跨越非可信网络进行互联时，我们可以为两个网络及其间传输的数据设定虚拟的安全标签，可以假设两个分支机构的安全级别均为”机秘”，而<code>Internet</code>，作为<code>VPN</code>的传输媒介，它的安全级别为”公开”，因此依照<code>BLP模型</code>，Internet上的用户仅可以看到”公开”的数据。而两个分支网络间的数据安全级别为”机秘”，因此，访问控制机制导致Internet用户不能访问”机秘”数据，而这是由于VPN使用了加密技术以实现访问控制机制。</p>
<p>　　另外的一个例子是防火墙所实现的单向访问机制，它不允许敏感数据从内部网络（例如，其安全级别为”机秘”）流向Internet（安全级别为”公开”），所有内部数据被标志为”机密”或”高密”。防火墙提供”上读”功能来阻止Internet对内部网络的访问，提供”下写”功能来限制进入内部的数据流只能经由由内向外发起的连接流入（例如，允许HTTP的”GET”操作而拒绝”POST”操作，或阻止任何外发的邮件）。</p>
<h2 id="Lattice安全模型"><a href="#Lattice安全模型" class="headerlink" title="Lattice安全模型"></a>Lattice安全模型</h2><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525324080_19633.png" alt=""></p>
<p>Lattice 模型通过划分安全边界对BLP模型进行了扩充，它将用户和资源进行分类，并允许它们之间交换信息，这是多边安全体系的基础。</p>
<p>　　多边安全的焦点是在不同的安全集束（部门，组织等）间控制信息的流动，而不仅是垂直检验其敏感级别。</p>
<p>　　建立多边安全的基础是为分属不同安全集束的主体划分安全等级，同样在不同安全集束中的客体也必须进行安全等级划分，一个主体可同时从属于多个安全集束，而一个客体仅能位于一个安全集束。</p>
<p>　　在执行访问控制功能时，lattice模型本质上同BLP模型是相同的，而lattice模型更注重形成”安全集束”。BLP模型中的”上读下写”原则在此仍然适用，但前提条件必须是各对象位于相同的安全集束中。主体和客体位于不同的安全集束时不具有可比性，因此在它们中没有信息可以流通。</p>
<p>　　例如，某用户有安全级别为”高密”并从属于安全集束”ALPHA”，另一个安全级别为”机密”的集束”BETA”中的用户试图访问从属于多个安全集束中的文件，若他需要访问集束”ALPHA”中安全级别为”机密”的文件，访问将被允许；而他访问集束”BETA”中的”机密”文件的试图将被拒绝。试图访问集束”GAMMA”中的任何对象都将被拒绝，因为其在集束”GAMMA”中不具有任何安全等级</p>
<h2 id="Biba完整性模型"><a href="#Biba完整性模型" class="headerlink" title="Biba完整性模型"></a>Biba完整性模型</h2><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525324129_14967.png" alt=""></p>
<p>七十年代，Ken Biba提出了Biba访问控制模型，该模型对数据提供了分级别的完整性保证，类似于BLP保密性模型，BIBA模型也使用强制访问控制系统。</p>
<p>　　Biba完整性模型对主体和客体按照强制访问控制系统的哲学进行分类，这种分类方法一般应用于军事用途。</p>
<p>　数据和用户被划分为以下安全等级</p>
<ul>
<li>公开（Unclassified）</li>
<li>受限（Restricted）</li>
<li>秘密（Confidential）</li>
<li>机密（Secret）</li>
<li>高密（Top Secret）</li>
</ul>
<p>BIBA模型基于两种规则来保障数据的完整性的保密性。</p>
<ul>
<li>下读(NRU) 属性, 主体不能读取安全级别低于它的数据</li>
<li>上写(NWD) 属性, 主体不能写入安全级别高于它的数据<br>  从这两个属性来看，我们发现Biba与BLP模型的两个属性是相反的，BLP模型提供保密性，而BIBA模型对于数据的完整性提供保障。</li>
</ul>
<p>　　BIBA模型并没有被用来设计安全操作系统，但大多数完整性保障机制都基于Biba模型的两个基本属性构建。</p>
<p>　　如图，一个安全级别为”机密”的用户要访问级别为”秘密”的文档，他将被允许写入该文档，而不能读取。如果他试图访问”高密”级的文档，那么，读取操作将被允许，而写入操作将被拒绝。这样，就使资源的完整性得到了保障。</p>
<p>　　因此，只有用户的安全级别高于资源的安全级别时可对资源进行写操作，相反地，只有用户的安全级别低于资源的安全经别时可读取该资源。简而言之，信息在系统中只能自上而下进行流动。</p>
<h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525324239_5044.png" alt=""></p>
<p>Biba模型在应用中的一个例子是对WEB服务器的访问过程。如图，定义Web服务器上发布的资源安全级别为”秘密”，Internet上用户的安全级别为”公开”，依照Biba模型，Web服务器上数据的完整性将得到保障，Internet上的用户只能读取服务器上的数据而不能更改它，因此，任何”POST”操作将被拒绝。</p>
<p>　　另一个例子是对系统状态信息的收集，网络设备作为对象，被分配的安全等级为”机密”，网管工作站的安全级别为”秘密”，那么网管工作站将只能使用SNMP的”get”命令来收集网络设备的状态信息，而不能使用”set”命令来更改该设备的设置。这样，网络设备的配置完整性就得到了保障。</p>
<h2 id="Clark-Wilson完整性模型"><a href="#Clark-Wilson完整性模型" class="headerlink" title="Clark Wilson完整性模型"></a>Clark Wilson完整性模型</h2><p>Clark-Wilson数据完整性安全模型是在1987年被提出的，通常被用在银行系统中来保证数据的完整性，该模型略显复杂，是为现代数据存储技术量身定制的。</p>
<p>　　Clark Wilson完整性模型经常应用在银行应用中以保证数据完整性，它的实现基于成形的事务处理机制。</p>
<ul>
<li>系统接受”自由数据条目 (UDI)”并将其转换为 “受限数据条目 (CDI)”</li>
<li>“受限数据条目 (CDI)”仅能被”转换程序（TP）”所改变</li>
<li>“转换程序 (TP)” 保证”受限数据条目 </li>
</ul>
<p>CDI”的完整性</p>
<ul>
<li>每个受限数据条目(CDI) 拥有一个完整性检查程序 (IVP)</li>
<li>访问控制机制由三个元素组成 (主体, TP, CDI)<h3 id="应用举例-1"><a href="#应用举例-1" class="headerlink" title="应用举例"></a>应用举例</h3><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525324526_13251.png" alt=""></li>
</ul>
<p>图所示为Clark Wilson完整性模型在电子商务程序中的应用，用户接到自主数据条目（UDI）并由转换程序（TP）将其转换为受限数据条目（CDI）CDI1，CDI1用来更新CDI2（例如客户的订单）和CDI3（如客户的帐单），完整性检查程序（IVP）总是要检查是否CDI2（订单）和CDI3（帐单）是否出入平衡，因此可确保整个交易的完整性。</p>
<h2 id="Chinese-Wall模型"><a href="#Chinese-Wall模型" class="headerlink" title="Chinese Wall模型"></a>Chinese Wall模型</h2><p>Chinese Wall模型是应用在多边安全系统中的安全模型（也就是多个组织间的访问控制系统），应用在可能存在利益冲突的组织中。最初是为投资银行设计的，但也可应用在其它相似的场合。</p>
<p>Chinese Wall安全策略的基础是客户访问的信息不会与目前他们可支配的信息产生冲突。在投资银行中，一个银行会同时拥有多个互为竞争者的客户，一个银行家可能为一个客户工作，但他可以访问所有客户的信息。因此，应当制止该银行家访问其它客户的数据。</p>
<p>Chinese Wall安全模型的两个主要属性：</p>
<ul>
<li>用户必须选择一个他可以访问的区域</li>
<li>用户必须自动拒绝来自其它与用户所选区域的利益冲突区域的访问<br>  这种模型同时包括了DAC和MAC的属性：银行家可以选择为谁工作（DAC），但是一旦选定，他就被只能为该客户工作（MAC）。</li>
</ul>
<h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525325785_22005.png" alt=""></p>
<p>Chinese Wall安全模型在网络安全体系中应用的一个典型的例子是位于防火墙内部的一台服务器，连接着内部与外部网络。假如策略禁止经由此服务器转发数据，该服务器将曝露于外部网络（也就是说，该服务器仅能与外部网络通讯，而不能与内部网络通讯）</p>
<p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525325812_5936.png" alt=""></p>
<p>　另外用远程访问VPN来举例说明，位于Internet上的用户与内部网络建立VPN会话之后。依照中国墙安全模型所建议，在任何时候，用户或与Internet通讯，或与公司网络进行通讯，二者只可选其一（也就是说：隧道不可分割）</p>
<p>　　单向会话只发生在有限的时间内，本安全模型的核心在于–用户选择与其中一方进行通讯，则放弃了与另一方会话的权利。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/Bypass-a-Path-Based-Access-Control/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/Bypass-a-Path-Based-Access-Control/" itemprop="url">Bypass-a-Path-Based-Access-Control</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T23:42:30+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Bypass-a-Path-Based-Access-Control"><a href="#Bypass-a-Path-Based-Access-Control" class="headerlink" title="Bypass_a_Path_Based_Access_Control"></a>Bypass_a_Path_Based_Access_Control</h1><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525273137_22137.png" alt=""></p>
<h2 id="技术概念或主题（Concept-Topic-To-Teach）"><a href="#技术概念或主题（Concept-Topic-To-Teach）" class="headerlink" title="技术概念或主题（Concept / Topic To Teach）"></a>技术概念或主题（Concept / Topic To Teach）</h2><p>In a path based access control scheme, an attacker can traverse a path by providing relative path information. Therefore an attacker can use relative paths to access files that normally are not directly accessible by anyone, or would otherwise be denied if requested directly. </p>
<h2 id="技术原理（How-It-works）"><a href="#技术原理（How-It-works）" class="headerlink" title="技术原理（How It works）"></a>技术原理（How It works）</h2><p>大多数操作系统允许在路径中使用某些特征字符，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/etc/passwd</span><br><span class="line">~/.ssh</span><br><span class="line">./configure</span><br><span class="line">./../../../etc/passwd</span><br><span class="line">c:\boot.ini</span><br><span class="line">.\test.txt</span><br><span class="line">..\..\..\boot.ini</span><br><span class="line">file:///c:\bbot.ini</span><br><span class="line">c:\test~1.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="总体目标（General-Goals）"><a href="#总体目标（General-Goals）" class="headerlink" title="总体目标（General Goals）"></a>总体目标（General Goals）</h2><p>The user should be able to access a file that is not in the listed directory.</p>
<h2 id="操作方法（Solutions）"><a href="#操作方法（Solutions）" class="headerlink" title="操作方法（Solutions）"></a>操作方法（Solutions）</h2><ul>
<li>选择一个文件，点击<code>View File</code>，然后抓包</li>
</ul>
<p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525274080_5639.png" alt=""></p>
<ul>
<li>根据页面给出的文件目录，把文件名改为<code>../../../WEB-INF/spring-security.xml</code>，出现以下结果</li>
</ul>
<p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525274191_21917.png" alt=""></p>
<ul>
<li>我的方法是正确的，但是这个危险的操作是被禁止的，改为<code>../ru/FailOpenAuthentication.html</code></li>
</ul>
<p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525274852_29261.png" alt=""></p>
<ul>
<li>还是不行，把<code>spring-security.xml</code>的权限改为<code>777</code>，仍然失败，gg。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/访问控制模型一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/访问控制模型一/" itemprop="url">访问控制模型一</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T22:35:28+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="访问控制模型一"><a href="#访问控制模型一" class="headerlink" title="访问控制模型一"></a>访问控制模型一</h1><h2 id="访问控制的概念"><a href="#访问控制的概念" class="headerlink" title="访问控制的概念"></a>访问控制的概念</h2><ul>
<li><strong>访问控制</strong>，作为提供信息安全保障的主要手段，及最为突出的安全机制, 被广泛地应用于防火墙、文件访问、VPN及物理安全等多个方面。 所有这些技术可归诸于几类访问控制模型，本文将一一介绍并以实例说明，以帮助设计者在多变的环境中解决相关安全问题。</li>
<li><strong>访问控制</strong>是信息安全保障机制的核心内容，它是实现<strong>数据保密性</strong>和<strong>完整性</strong>机制的主要手段。</li>
<li><strong>访问控制</strong>是为了限制<strong>访问主体</strong>（或称为发起者，是一个主动的实体；如用户、进程、服务等），对<strong>访问客体</strong>（需要保护的资源）的访问权限，从而使计算机系统在合法范围内使用；</li>
<li><strong>访问控制</strong>机制决定用户及代表一定用户利益的程序能做什么，及做到什么程度。</li>
</ul>
<h3 id="访问控制的两个重要过程"><a href="#访问控制的两个重要过程" class="headerlink" title="访问控制的两个重要过程"></a>访问控制的两个重要过程</h3><ul>
<li>通过”鉴别（<code>authentication</code>）”来检验主体的合法身份</li>
<li>通过”授权（<code>authorization</code>）”来限制用户对资源的访问级别</li>
</ul>
<h3 id="访问行为"><a href="#访问行为" class="headerlink" title="访问行为"></a>访问行为</h3><ul>
<li>访问包括读取数据，更改数据，运行程序，发起连接等。</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>访问控制服务主要由<strong>访问控制模型</strong>和<strong>策略描述语言</strong>组成 </li>
<li>常见的访问控制模型主要是自主访问控制 <code>DAC</code>、强制访问控制 <code>MAC</code>、基于角色的访问控制 <code>RBAC</code>。 </li>
<li><strong>访问策略规则</strong>以及<strong>访问主体</strong>和<strong>访问客体</strong>三者是访问控制系统的基本条件。 </li>
<li><strong>访问主体</strong>：在信息环境中，对目标信息的获取通常是由访问主体发起的，访问主体需要遵循相应的规则，从而可以访问一定的客体。通常访问主体是用户开发和使用的应用程度。 </li>
<li><strong>访问客体</strong>：在信息系统中，客体可以被主体进行一定的访问行为操作。 </li>
<li><strong>安全访问策略</strong>：是为了保护信息安全性而制定的策略规则，规定了主体是否可以访问客体以及可以使用何种方式对客体进行访问。 </li>
<li>经典的三大模型<code>DAC</code>、<code>MAC</code>、<code>RBAC</code>，虽然现在在学术界这三大模型都遭到嫌弃，但是现有的访问控制模型其实都是在这三大模型上改改写写的。</li>
</ul>
<h2 id="自主访问控制（DAC-Discretionary-Access-Control）"><a href="#自主访问控制（DAC-Discretionary-Access-Control）" class="headerlink" title="自主访问控制（DAC,Discretionary Access Control）"></a>自主访问控制（DAC,Discretionary Access Control）</h2><ul>
<li>自主访问控制（<code>DAC</code>,<code>Discretionary Access Control</code>）比较基础和常用，在多种计算机系统中都会提供自主访问控制。</li>
<li>此种访问控制的基本思想是：访问控制中访问客体的拥有者具有很大的权限，能够决定客体是否可以被相应主体访问，并且可以迁移和转让访问客体。</li>
<li>在 <code>DAC</code> 模型中，访问权限是否进行授权需要根据主体情况并结合具体的安全规则从而做出判断。</li>
<li><code>DAC</code> 有<strong>访问控制矩阵</strong>和<strong>访问控制列表</strong>两种实施方式。 <h3 id="访问控制矩阵"><a href="#访问控制矩阵" class="headerlink" title="访问控制矩阵"></a>访问控制矩阵</h3>访问控制矩阵（<code>ACM</code>：<code>Acess Control Matrix</code>）中使用矩阵的列和行来分别对应访问主体和访问客体，二者交叉位置的元素则代表着相应的主体对客体的操作规则。<br><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525256809_605.png" alt=""><h3 id="访问控制列表"><a href="#访问控制列表" class="headerlink" title="访问控制列表"></a>访问控制列表</h3></li>
<li>访问控制列表（<code>ACL</code>：<code>Access Control List</code>）是前面说介绍矩阵的一种变形。</li>
<li>列表对应某个固定客体，其中的列表示能够对此客体进行一定操作的主体。</li>
<li>第二列访问属性则表示二者对应的具体操作。如表 所示，是上表中客体 X 所对应的等价控制矩阵转化。</li>
<li>通过 <code>ACL</code> 可以方便的理解和查询某个客体所对应的特定权限主体，适用于稳定的主客体不太复杂的系统。在信息系统发生较大改变时，需要重新对访问控制列表进行相应修改，容易影响系统安全性。</li>
</ul>
<p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525256836_10032.png" alt=""></p>
<p><code>DAC</code> 在进行授权时相对灵活，访问控制中客体的所有者可以将其所有用的权限进行转移，从而具有很好的灵活性，适用范围比较广，因而可以用于多个系统。但是，<code>DAC</code> 存在几个缺点：</p>
<ul>
<li>由于权限可以进行委托，会导致资源管理比较分散，同时增加了系统的风险性。 </li>
<li>不能够适应多域安全策略环境，以及在环境策略变化的情况下无法保证整体的安全性。 </li>
<li>访问控制权限容易发生转移，同时，在主体与客体数量较多时，会给系统带来巨大开销，导致效率低下，<strong>不能很好的适应交大规模的网络环境</strong>。</li>
</ul>
<h2 id="强制访问控制（MAC）"><a href="#强制访问控制（MAC）" class="headerlink" title="强制访问控制（MAC）"></a>强制访问控制（MAC）</h2><ul>
<li>强制访问控制（<code>MAC</code>：<code>Mandatory Acess Control</code>）在十八世纪七十年代就已经提出，在 <code>Multics</code> 模型上得到最早使用和验证，与前面介绍的自主访问控制相比，定义规则和策略相对更加严格。</li>
<li><code>MAC</code> 设计的基本思想是：在访问控制系统中，主体和客体被分配一定的安全属性，然后系统对二者所拥有的属性关系进行一定的评价比较，从而确定是否进行访问。</li>
<li>也就是说这是一种多级表示模型。比较关系来源于安全属性，并且用（安全级别，类型集合）这样的组合代表安全属性。</li>
<li>类型集合是指一定的元素的集体，而安全等级则表示相应信息的保密等级。在系统中安全属性是由维护系统的管理人员进行配置的，或者是系统自动生成的，这种安全属性是不能随意被修改的，具有强制认可性。 </li>
<li><code>MAC</code> 具有强制性和严格的单向不可逆性。</li>
<li><code>MAC</code> 系统规定高级别主体可以得到低级别主体的信息，而反过来却行不通。</li>
<li>如果主体<code>A</code> 的级别高于客体<code>B</code>，那么主体 <code>A</code> 可以读取客体<code>B</code> 中的信息和资源；如果主体 <code>A</code> 的级别低于主体 <code>B</code> 的级别，那么主体 <code>A</code> 可以对主体 <code>B</code> 进行一定的诸如写入的操作；如果主体 <code>A</code>和客体<code>B</code>的等级是相同的，那么主体<code>A</code> 和客体 <code>B</code> 之间不能进行任何读与写的操作。</li>
<li>这意味着在 <code>MAC</code> 模型的信息始终遵循单向流通的规则，因而可以保证系统信息的安全。如图 所示。</li>
</ul>
<p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525256893_20596.png" alt=""></p>
<p>强制访问控制中最具有代表性的就是 <code>BLP</code> 模型。</p>
<h2 id="基于角色的访问控制（RBAC）"><a href="#基于角色的访问控制（RBAC）" class="headerlink" title="基于角色的访问控制（RBAC）"></a>基于角色的访问控制（RBAC）</h2><ul>
<li>基于角色的访问控制（<code>RBAC</code>）是在上世纪九十年代被提出，是一种评估效果比较好的访问控制信息技。</li>
<li>在此种模型中，主体与客体并不是直接发生联系，而是增加了角色这一层次，先将访问操作的权限匹配给某些角色，然后在将这些特定的角色指定给相应的主体，通过这种方式主体就得到了对客体的访问权限。</li>
</ul>
<p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525256928_28770.png" alt=""></p>
<p>基于角色使得主体和客体之间的关系不是通过他们之间的映射来建立，而是中间有了周转，多了一个角色这个中转站。</p>
<h4 id="RBAC模型简介"><a href="#RBAC模型简介" class="headerlink" title="RBAC模型简介"></a>RBAC模型简介</h4><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525258602_21653.png" alt=""></p>
<ul>
<li>模型中主要定义了：用户(<code>User</code>)，角色(<code>Role</code>)和用户权限（<code>Permission</code>）三个主要实体，以及会话(<code>Session</code>)和限制(<code>Constraint</code>)的概念及其之间的关系。</li>
<li>其中，权限是指针对信息系统的操作权利，不同的角色或者不同级别的角色被赋予不同的权限，系统用户又被赋予一定的(一个或多个)角色。从而用户与角色之间，角色和权限之间均是一个多对多的<br>关系，用户和权限之间则没有直接的关系，而是根据所具有的责任被赋予某种角色，从而拥有角色相<br>应的权限。其授权模型示意图如上图所示。</li>
<li>在<code>RBAC</code>模型中，角色是一个相对的概念，用户与角色之间是多对多的关系，并且这一关系可以迅速变化，即用户所”扮演”的角色可以经常的发生变化；角色与权限之间也是多对多的关系，但是这一关系的变化则相对比较的缓慢，即角色拥有的权限是相对稳定。</li>
<li>会话集合中的每个黑点代表一个会话，它控制一个用户的多个角色，有效的控制角色之间的冲突。</li>
<li>即当一个被赋予多个角色的用户使用系统时，这些角色将分为属于若干个会话。</li>
<li>用户在任一时间内，只激活一个会话，从而用户在该时间类仅能扮演该激活会话中所包含的角色，其他角色在该段时间将为禁用。</li>
<li>使用<code>RBAC</code>模型能够通过用户授权(给用户指定角色)和角色授权(给角色分配操作权限)二个步骤实现完善的用户权限管理。<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2>然后随着云计算的出现，又出现了基于属性的访问控制<code>ABAC</code>，大家可以自行去查资料。基于属性的访问控制很厉害，它具有环境属性，而且可以把角色啊、客体啊、主体啊都当作一种属性，这种细粒度的访问控制安全性能很强，而且还能把数据挖掘的思想运用进来。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/Using-an-Access-Control-Matrix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/Using-an-Access-Control-Matrix/" itemprop="url">Using-an-Access-Control-Matrix</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T11:03:27+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Using-an-Access-Control-Matrix"><a href="#Using-an-Access-Control-Matrix" class="headerlink" title="Using_an_Access_Control_Matrix"></a>Using_an_Access_Control_Matrix</h1><p>使用访问控制模型<br><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525229245_8386.png" alt=""></p>
<h2 id="技术概念或主题（Concept-Topic-To-Teach）"><a href="#技术概念或主题（Concept-Topic-To-Teach）" class="headerlink" title="技术概念或主题（Concept / Topic To Teach）"></a>技术概念或主题（Concept / Topic To Teach）</h2><blockquote>
<p>In a role-based access control scheme, a role represents a set of access permissions and privileges. A user can be assigned one or more roles. A role-based access control scheme normally consists of two parts: role permission management and role assignment. A broken role-based access control scheme might allow a user to perform accesses that are not allowed by his/her assigned roles, or somehow allow privilege escalation to an unauthorized role.</p>
</blockquote>
<blockquote>
<p>在一个基于角色的访问控制方案中，角色代表了一组访问权限和特权。一个用户可以被<br>分配一个或多个角色。一个基于角色的访问控制方案通常有两个部分组成：角色权限管理和<br>角色分配。一个被破坏的基于角色的访问控制方案可能允许用户执行不允许他/她的被分配<br>的角色，或以某种方式允许特权升级到未经授权的角色的访问。</p>
</blockquote>
<h2 id="技术原理（How-It-works）"><a href="#技术原理（How-It-works）" class="headerlink" title="技术原理（How It works）"></a>技术原理（How It works）</h2><p>这个控制方案本身有缺陷</p>
<h2 id="总体目标（General-Goals）"><a href="#总体目标（General-Goals）" class="headerlink" title="总体目标（General Goals）"></a>总体目标（General Goals）</h2><blockquote>
<p>Each user is a member of a role that is allowed to access only certain resources. Your goal is to explore the access control rules that govern this site. Only the [Admin] group should have access to the ‘Account Manager’ resource.</p>
</blockquote>
<blockquote>
<p>每个用户都是角色的成员，每个角色只允许访问那些特定的资源。您的目标是浏览本站<br>管理所使用的访问控制规则。只有“Admin”组才能够访问“帐号管理”资源。</p>
</blockquote>
<h2 id="操作方法（Solutions）"><a href="#操作方法（Solutions）" class="headerlink" title="操作方法（Solutions）"></a>操作方法（Solutions）</h2><blockquote>
<p>This exercise is straightforward. You need to find a user where you can access a resource that you shouldn’t be able to access.</p>
</blockquote>
<p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525229372_2326.png" alt=""></p>
<blockquote>
<p>After a few attempts you will learn that Larry can access resources of the role Account Manager.</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/HTTP请求报文/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/HTTP请求报文/" itemprop="url">HTTP报文</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T09:30:30+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h1><h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq= HTTP/1.1 </span><br><span class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, </span><br><span class="line">application/msword, application/x-silverlight, application/x-shockwave-flash, */* </span><br><span class="line">Referer: &lt;http://www.google.cn/&gt; </span><br><span class="line">Accept-Language: zh-cn </span><br><span class="line">Accept-Encoding: gzip, deflate </span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld) </span><br><span class="line">Host: [www.google.cn](http://www.google.cn/) </span><br><span class="line">Connection: Keep-Alive </span><br><span class="line">Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g;</span><br><span class="line">NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y- </span><br><span class="line">FxlRugatx63JLv7CWMD6UB_O_r</span><br></pre></td></tr></table></figure>
<p>观察发现，报文是用普通的<code>ASCII</code>文本书写。</p>
<p>其次，报文有很多行，每行用一个回车换行符结束。 </p>
<p>第一行：请求行（<code>request line</code>），</p>
<p>第一行后面的行，为请求头部（<code>header</code>）。 </p>
<p>然后是一个空行，最下面是请求数据。</p>
<p><img src="https://github.com/Anthem9/everyday/raw/master/image/593225-20151228140454010-1128568448.png" alt=""></p>
<p>###请求行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq= HTTP/1.1</span><br></pre></td></tr></table></figure>
<p><strong>有3个字段：方法字段，URL字段，HTTP协议版本字段。</strong> </p>
<ul>
<li>方法字段：<code>GET</code>, <code>POST</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code>。</li>
<li>当浏览器请求一个对象时，使用<code>GET</code>方法，在<code>URL</code>字段填写该对象的<code>URL</code>地址。 </li>
<li><code>HTTP</code>协议版本</li>
</ul>
<h4 id="1-GET"><a href="#1-GET" class="headerlink" title="1).GET"></a><strong>1).GET</strong></h4><p>最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是<code>GET</code>方式。<code>GET</code>方法要求服务器将<code>URL</code>定位的资源放在响应报文的数据部分，回送给客户端。使用<code>GET</code>方法时，请求参数和对应的值附加在<code>URL</code>后面，利用一个问号<code>?</code>代表<code>URL</code>的结尾与请求参数的开始，传递参数长度受限制。例如，<code>/index.jsp?id=100&amp;op=bind</code>,这样通过<code>GET</code>方式传递的数据直接表示在地址中，所以我们可以把请求结果以链接的形式发送给好友。以用<code>google</code>搜索<code>domety</code>为例，<code>Request</code>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq= HTTP/1.1  </span><br><span class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, </span><br><span class="line">application/msword, application/x-silverlight, application/x-shockwave-flash, */*  </span><br><span class="line">Referer: &lt;a href=&quot;http://www.google.cn/&quot;&gt;http://www.google.cn/&lt;/a&gt;  </span><br><span class="line">Accept-Language: zh-cn  </span><br><span class="line">Accept-Encoding: gzip, deflate  </span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  </span><br><span class="line">Host: &lt;a href=&quot;http://www.google.cn&quot;&gt;www.google.cn&lt;/a&gt;  </span><br><span class="line">Connection: Keep-Alive  </span><br><span class="line">Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; </span><br><span class="line">NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-</span><br><span class="line">FxlRugatx63JLv7CWMD6UB_O_r</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>GET</code>方式的请求一般不包含”请求内容”部分，请求数据以地址的形式表现在请求行。地址链接如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.google.cn/search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq=&quot;&gt;http://www.google.cn/search?hl=zh-CN&amp;source=hp</span><br><span class="line">&amp;q=domety&amp;aq=f&amp;oq=&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>地址中<code>?</code>之后的部分就是通过<code>GET</code>发送的请求数据，我们可以在地址栏中清楚的看到，各个数据之间用<code>&amp;</code>符号隔开。显然，这种方式不适合传送私密数据。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别<code>1024</code>个字符，所以如果需要传送大量数据的时候，也不适合使用<code>GET</code>方式。</p>
<h4 id="2-POST"><a href="#2-POST" class="headerlink" title="2).POST"></a>2).POST</h4><p>对于上面提到的不适合使用<code>GET</code>方式的情况，可以考虑使用<code>POST方</code>式，因为使用<code>POST</code>方法可以允许客户端给服务器提供较多信息。<code>POST</code>方法将请求参数封装在<code>HTTP</code>请求数据中，以<code>名称/值</code>的形式出现，可以传输大量数据，这样<code>POST</code>方式对传送的数据大小没有限制，而且也不会显示在<code>URL</code>中。还以上面的搜索<code>domety</code>为例，如果使用<code>POST</code>方式的话，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1  </span><br><span class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, </span><br><span class="line">application/msword, application/x-silverlight, application/x-shockwave-flash, */*  </span><br><span class="line">Referer: &lt;a href=&quot;http://www.google.cn/&quot;&gt;http://www.google.cn/&lt;/a&gt;  </span><br><span class="line">Accept-Language: zh-cn  </span><br><span class="line">Accept-Encoding: gzip, deflate  </span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  </span><br><span class="line">Host: &lt;a href=&quot;http://www.google.cn&quot;&gt;www.google.cn&lt;/a&gt;  </span><br><span class="line">Connection: Keep-Alive  </span><br><span class="line">Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; </span><br><span class="line">NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-</span><br><span class="line">FxlRugatx63JLv7CWMD6UB_O_r  </span><br><span class="line"></span><br><span class="line">hl=zh-CN&amp;source=hp&amp;q=domety</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>POST</code>方式请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用<code>&amp;</code>符号隔开。<code>POST</code>方式大多用于页面的表单中。因为<code>POST</code>也能完成<code>GET</code>的功能，因此多数人在设计表单的时候一律都使用<code>POST</code>方式，其实这是一个误区。<code>GET</code>方式也有自己的特点和优势，我们应该根据不同的情况来选择是使用<code>GET</code>还是使用<code>POST</code>。</p>
<h4 id="3-HEAD"><a href="#3-HEAD" class="headerlink" title="3).HEAD"></a><strong>3).HEAD</strong></h4><p><code>HEAD</code>就像<code>GET</code>，只不过服务端接受到<code>HEAD</code>请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用<code>HEAD</code>是非常高效的，因为在传输的过程中省去了页面内容。</p>
<h3 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h3><p>请求头部提供的信息是<code>WEB</code>代理缓存所要求的。</p>
<p>请求头部由<code>关键字/值</code>对组成，每行一对，关键字和值用英文冒号<code>:</code>分隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: &lt;a href=&quot;http://www.google.cn&quot;&gt;www.google.cn&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>定义了目标所在的主机。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>
<p>浏览器告诉服务器使用持久连接， <code>close</code> 则 使用非持久连接，即要求服务器在发送请求的对象后就关闭连接，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)</span><br></pre></td></tr></table></figure>
<p>定义用户代理，即向服务器发送请求的浏览器类型。<code>Mozilla/4.0</code>为<code>Netscape</code>浏览器。因此服务器可以正确地为不同类型的用户代理实际发送相同的对象不同的版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Language: zh-cn</span><br></pre></td></tr></table></figure>
<p>表示用户想得到该对象的语言版本,<strong>也可以作为用户地区的判断。</strong></p>
<p><strong>CLIENT-IP、X-FORWARDED-FOR、REMOTE_ADDR</strong></p>
<p>共同：后面加IP地址，<strong>可以用于服务端获取客户端的IP。</strong></p>
<p>区别：</p>
<ol>
<li><code>CLIENT-IP</code>头是有的，只是未成标准，不一定服务器都实现了。</li>
<li><code>X-FORWARDED-FOR</code> 是有标准定义，用来识别经过HTTP代理后的客户端IP地址，格式：<code>clientip</code>,<code>proxy1</code>,<code>proxy2</code>。可以被修改欺骗。</li>
<li><code>REMOTE-ADDR</code> 是可靠的， 它是最后一个跟你的服务器握手的<code>IP</code>，在<code>curl</code>中也无法伪造是，相对比较安全的服务端ip获取方法。</li>
</ol>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p>
<h3 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h3><p>请求数据不在<code>GET</code>方法中使用，而是在<code>POST</code>方法中使用。<code>POST</code>方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是<code>Content-Type</code>和<code>Content-Length</code>。</p>
<h2 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 31 Dec 2005 23:59:59 GMT</span><br><span class="line">Connection: Keep-Alive </span><br><span class="line">Content-Type: text/html;charset=ISO-8859-1</span><br><span class="line">Content-Length: 122</span><br><span class="line"></span><br><span class="line">＜html＞</span><br><span class="line">＜head＞</span><br><span class="line">＜title＞Wrox Homepage＜/title＞</span><br><span class="line">＜/head＞</span><br><span class="line">＜body＞</span><br><span class="line">＜!-- body goes here --＞</span><br><span class="line">＜/body＞</span><br><span class="line">＜/html＞1234567891011121314</span><br></pre></td></tr></table></figure>
<p><code>HTTP</code>响应也由三个部分组成，分别是：状态行、响应头部、空白行、响应实体。</p>
<p>如下所示，<code>HTTP</code>响应的格式与请求的格式十分类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">＜status-line＞</span><br><span class="line"></span><br><span class="line">＜headers＞</span><br><span class="line"></span><br><span class="line">＜blank line＞</span><br><span class="line"></span><br><span class="line">[＜response-body＞]</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Anthem9/everyday/raw/master/image/%E4%B8%8B%E8%BD%BD.png" alt=""></p>
<p> 正如你所见，在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息。状态行（<code>status line</code>）通过提供一个状态码来说明所请求的资源情况。</p>
<h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>状态行有3个字段：协议版本，状态码，相应状态信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>
<p>在这个例子中，状态行指示服务器使用的协议是<code>HTTP/1.1</code>，并且一切正常(服务器已找到并正在发送所请求的对象)</p>
<p>状态行格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP-Version Status-Code Reason-Phrase CRLF</span><br></pre></td></tr></table></figure>
<p>其中，<code>HTTP-Version</code>表示服务器HTTP协议的版本；<code>Status-Code</code>表示服务器发回的响应状态代码；<code>Reason-Phrase</code>表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。</p>
<ul>
<li>1xx：指示信息–表示请求已接收，继续处理。</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受。</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求。</li>
</ul>
<p>常见状态代码、状态描述的说明如下。</p>
<ul>
<li>200 OK：客户端请求成功。</li>
<li>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。</li>
<li>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</li>
<li>403 Forbidden：服务器收到请求，但是拒绝提供服务。</li>
<li>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</li>
<li>500 Internal Server Error：服务器发生不可预期的错误。</li>
<li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</li>
</ul>
<h3 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure>
<p>这个响应头部告诉客户机在报文发送完后关闭了该TCP连接。</p>
<ul>
<li><code>Date</code>：指示服务器产生并发送该相应报文的日期和时间。这个时间是服务器从他的文件系统中检索到该对象。插入到响应报文并发送响应报文的时间。 </li>
</ul>
<ul>
<li><code>Server</code>:表明该报文是由一个什么服务器产生的，类似于请求报文中的User-agent:请求头部 </li>
</ul>
<ul>
<li><code>Last-Modified</code>:表示对象创建会最后修改的日期和时间，这个首部行对可能在客户机也可能在网络缓存服务器上的对象缓存很重要。 </li>
<li><code>Content-Length</code>:表明被发送对象的字节数。 </li>
<li><code>Content-Type</code>:指示了实体主体中的对象时什么类型的文本如HTML文本，JSON对象文本</li>
</ul>
<h4 id="关于HTTP请求GET和POST的区别"><a href="#关于HTTP请求GET和POST的区别" class="headerlink" title="关于HTTP请求GET和POST的区别"></a><strong>关于HTTP请求GET和POST的区别</strong></h4><h5 id="1-区别"><a href="#1-区别" class="headerlink" title="1. 区别"></a>1. 区别</h5><p><code>GET</code>提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头<code>＜request-line＞</code>中），以<code>?</code>分割<code>URL</code>和传输数据，多个参数用&amp;连接;例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD</span><br></pre></td></tr></table></figure>
<p>如果数据是英文字母/数字，原样发送，如果是空格，转换为<code>+</code>，如果是中文/其他字符，则直接把字符串用<code>BASE64</code>加密，得出如： <code>%E4%BD%A0%E5%A5%BD</code>，其中<code>％XX</code>中的<code>XX</code>为该符号以<code>16进制</code>表示的<code>ASCII</code>。</p>
<p><code>POST</code>提交：把提交的数据放置在是<code>HTTP</code>包的包体<code>＜request-body＞</code>中。上文示例中红色字体标明的就是实际的传输数据</p>
<p>因此，<code>GET</code>提交的数据会在地址栏中显示出来，而<code>POST</code>提交，地址栏不会改变</p>
<h5 id="2-传输数据的大小："><a href="#2-传输数据的大小：" class="headerlink" title="2. 传输数据的大小："></a>2. 传输数据的大小：</h5><p>首先声明,<code>HTTP</code>协议没有对传输的数据大小进行限制，<code>HTTP</code>协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有：</p>
<p><code>GET</code>:特定浏览器和服务器对<code>URL</code>长度有限制，例如<code>IE</code>对<code>URL</code>长度的限制是2083字节(2K+35)。对于其他浏览器，如<code>Netscape</code>、<code>FireFox</code>等，理论上没有长度限制，其限制取决于操作系统的支持。</p>
<p>因此对于<code>GET</code>提交时，传输数据就会受到<code>URL</code>长度的限制。</p>
<p><code>POST</code>:由于不是通过<code>URL</code>传值，理论上数据不受限。但实际各个<code>WEB</code>服务器会规定对<code>post</code>提交数据大小进行限制，<code>Apache</code>、<code>IIS6</code>都有各自的配置。</p>
<h5 id="3-安全性："><a href="#3-安全性：" class="headerlink" title="3. 安全性："></a>3. 安全性：</h5><p>​    <code>POST</code>的安全性要比<code>GET</code>的安全性高。注意：这里所说的安全性和上面<code>GET</code>提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的<code>Security</code>的含义，比如：通过<code>GET</code>提交数据，用户名和密码将明文出现在<code>URL</code>上，因为<br>(1)登录页面有可能被浏览器缓存，<br>(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/WebGoat-General-HTTP-Basics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/WebGoat-General-HTTP-Basics/" itemprop="url">WebGoat_General_HTTP_Basics</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T09:03:41+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="WebGoat-HTTP-basics"><a href="#WebGoat-HTTP-basics" class="headerlink" title="WebGoat_HTTP_basics"></a>WebGoat_HTTP_basics</h1><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/_v_images/_1525221121_20356.png" alt=""></p>
<h2 id="技术概念或主题（Concept-Topic-To-Teach）"><a href="#技术概念或主题（Concept-Topic-To-Teach）" class="headerlink" title="技术概念或主题（Concept / Topic To Teach）"></a>技术概念或主题（Concept / Topic To Teach）</h2><p>This lesson presents the basics for understanding the transfer of data between the browser and the web application.</p>
<h2 id="技术原理（How-It-works）"><a href="#技术原理（How-It-works）" class="headerlink" title="技术原理（How It works）"></a>技术原理（How It works）</h2><p>Client Request: How HTTP works:</p>
<p>All HTTP transactions follow the same general format. Each client request and server response has three parts: <strong>the request or response line</strong>, <strong>a header section</strong>, and <strong>the entity body</strong>. The client initiates a transaction as follows: </p>
<p>The client contacts the server and sends a document request<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html?param=value HTTP/1.0</span><br></pre></td></tr></table></figure></p>
<p>Next, the client sends optional header information to inform the server of its configuration and the document formats it will accept.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/4.06 Accept: image/gif, image/jpeg, */*</span><br></pre></td></tr></table></figure></p>
<p>After sending the request and headers, the client may send additional data. This data is mostly used by CGI programs using the POST method.</p>
<h2 id="总体目标（General-Goals）"><a href="#总体目标（General-Goals）" class="headerlink" title="总体目标（General Goals）"></a>总体目标（General Goals）</h2><ul>
<li>Enter your name in the input field below and press “go” to submit. The server will accept the request, reverse the input, and display it back to the user, illustrating the basics of handling an HTTP request. </li>
<li>练习使用抓包工具<h2 id="操作方法（Solutions）"><a href="#操作方法（Solutions）" class="headerlink" title="操作方法（Solutions）"></a>操作方法（Solutions）</h2></li>
<li>设置浏览器代理，抓包，没啥好说的</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/WebGoat启程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/WebGoat启程/" itemprop="url">WebGoat启程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T06:33:43+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="WebGoat启程"><a href="#WebGoat启程" class="headerlink" title="WebGoat启程"></a>WebGoat启程</h1><h2 id="前言-amp-闲聊"><a href="#前言-amp-闲聊" class="headerlink" title="前言&amp;闲聊"></a>前言&amp;闲聊</h2><p>前几天给一个国外的留学生做他们的信息安全课程的作业，其中就有<code>WebGoat</code>的部分，感觉这个靶场很不错，于是决定来刷一波。</p>
<h2 id="WebGoat简介"><a href="#WebGoat简介" class="headerlink" title="WebGoat简介"></a>WebGoat简介</h2><blockquote>
<p><code>WebGoat</code>是一个用于讲解典型<code>web</code>漏洞的基于<code>J2EE</code>架构的<code>web</code>应用，他由著名的<code>WEB</code>应用安全研究组织<code>OWASP</code>精心设计并不断更新。<code>WebGoat</code>本身是一系列教程，其中设计了大量的<code>web</code>缺陷，一步步的指导用户如何去利用这些漏洞进行攻击，同时也指出了如何在程序设计和编码时避免这些漏洞。<code>Web</code>应用程序的设计者和测试者都可以在<code>WebGoat</code>中找到自己感兴趣的部分。虽然<code>WebGoat</code>中对于如何利用漏洞给出了大量的解释，但是还是比较有限，尤其是对于初学者来说，但觉得这正是其特色之处：<code>WebGoat</code>的每个教程都明确告诉你存在什么漏洞，但是如何去攻破要你自己去查阅资料，了解该漏洞的原理、特征和攻击方法，甚至要自己去找攻击辅助工具，当你成功时，<code>WebGoat</code>会给出一个红色的<code>Congratulation</code>，让你很有成就感！<br>[看雪论坛]</p>
</blockquote>
<h2 id="WebGoat部署"><a href="#WebGoat部署" class="headerlink" title="WebGoat部署"></a>WebGoat部署</h2><p>使用docker<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull webgoat/webgoat-<span class="number">7.1</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -p 8080:8080 -idt webgoat/webgoat-7.1</span></span><br></pre></td></tr></table></figure></p>
<p>打开<code>192.168.99.100:8080/WebGoat</code></p>
<h2 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h2><ul>
<li>Burp Suite</li>
<li>开发者工具</li>
</ul>
<hr>
<p>date: 2018-05-02 08:58:43</p>
<hr>
<h2 id="WriteUp格式"><a href="#WriteUp格式" class="headerlink" title="WriteUp格式"></a>WriteUp格式</h2><ul>
<li><p>一般来说直接复制英文的教程，其中一些跟教程不一样或者有些自己的理解的地方，会给出中文注释</p>
</li>
<li><p>不光是完成<code>WebGoat</code>的目标，大部分内容都会有相应的拓展。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/28/2018-4-28-周记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/28/2018-4-28-周记/" itemprop="url">2018.4.28 周记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-28T14:49:53+08:00">
                2018-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="打坐和念经"><a href="#打坐和念经" class="headerlink" title="打坐和念经"></a>打坐和念经</h1><h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h2><p>这个周总算是把Blog搞起来了，Blog的作用就是记录，记录一点一滴的成长，是督促也是奖励。</p>
<h2 id="日语"><a href="#日语" class="headerlink" title="日语"></a>日语</h2><p>还是想学日语，就在网上报了一个班，一个周六小时。希望能坚持下去。</p>
<h2 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h2><p>写这篇周记的时候正在打国赛，打不动跑来写周记了…太JB难了，为毛现在都是Web + PWN</p>
<p>趁WhaleCTF没开始下一期打卡赶紧把前面学的复习一遍</p>
<p>昨天做了一道PWN，感觉非常妙，我就是觉得CTF选手不应该局限在某一个方向，你看缓冲区溢出实际上跟SQL注入的原理是一样的，都是缺少对用户输入的校验。</p>
<h2 id="牙"><a href="#牙" class="headerlink" title="牙"></a>牙</h2><p>周一去种了牙，周二周三还难受，现在基本正常了。</p>
<p>买了一个电动牙刷和脱敏牙膏，医生说还要用牙线，我还没买，再说吧。</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>接到了第一份和我专业相关的工作，是给一个国外的留学生写作业，这个留学生应该也是信息安全专业的，他们的作业真的是好棒，通过模拟实战进行渗透练习，用的也是著名的Web靶场WebGoat和一个TCP软件VulnServer。还没做之前就感觉做完肯定能学到东西，结果也确实是这样，不过作业毕竟是作业，WebGoat这个靶场还没有被完全利用，我想（Flag）抽时间把WebGoat刷完。复习完WhaleCTF再学习VulnServer。</p>
<p>寻找资料的过程发现很多资料都使用了Metasploit，神器真的要好好学习一下。</p>
<p>还有为了大洋彼岸的这位仁兄做作业，强迫自己读了大量英语文献，虽然比较痛苦，有些只能不停的去查Google，但是确实感觉英语水平有了提升，看着满篇英语舒服一点了…这算抖M嘛…</p>
<h2 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h2><p>马上就要微积分大物离散数学的期中考试了，数学实验什么的…我当初就不应该选，有了Python还用什么Matlab。</p>
<p>5.1假期就老老实实复习吧，毕竟大物一节课都没听。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>上面是流水账，下面正文开始~</p>
<p>首先是遇到了一个有趣的女生，但是我觉得要请奶茶不太容易。2333333</p>
<p>但是心中是有了一种安心的感觉，不知道为什么，我不想去想，不想去解释，就这样，挺好。</p>
<p>很美妙，她有魔力能让我浮躁的心静下来，安心的做事，专注的做事。我猛然醒悟，这正是我现在最欠缺的东西，眼高手低，心浮气躁已经开始影响我的心智，怪不得ESR说黑客喜欢参禅和习武，并且注重“道“的领悟，我初看时还疑惑，纳闷外国人怎么还好这些虚无的东西。但现在我觉得，佛教的打坐念经，道教的入定，武功的悟道，瑜伽的冥想，心理学里的催眠术，这些似乎都是通过引导，清空人内心的杂念，从而使人能够更加专注的工作和学习。算是磨刀不误砍柴工。</p>
<p>或许可以尝试一下。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/26/Docker安装文本编辑器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/26/Docker安装文本编辑器/" itemprop="url">Docker安装文本编辑器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-26T19:37:20+08:00">
                2018-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Docker安装文本编辑器"><a href="#Docker安装文本编辑器" class="headerlink" title="Docker安装文本编辑器"></a>Docker安装文本编辑器</h1><p>在使用<code>docker</code>容器时，有时候里边没有安装<code>vim</code>，敲<code>vim</code>命令时提示说：<code>vim: command not found</code>，这个时候就需要安装<code>vim</code>，可是当你敲<code>apt-get install vim</code>命令时，提示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Reading package lists... Done </span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done </span><br><span class="line">E: Unable to locate package vim</span><br></pre></td></tr></table></figure></p>
<p>这时候需要敲：<code>apt-get update</code>，这个命令的作用是：同步 <code>/etc/apt/sources.list</code> 和 <code>/etc/apt/sources.list.d</code> 中列出的源的索引，这样才能获取到最新的软件包。 </p>
<p>等更新完毕以后再敲命令：<code>apt-get install vim</code>命令即可。</p>
<p>注：<code>apt-get install vi</code>也是找不到的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
