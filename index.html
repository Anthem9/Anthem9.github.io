<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/访问控制模型一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/访问控制模型一/" itemprop="url">访问控制模型一</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T22:35:28+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="访问控制模型一"><a href="#访问控制模型一" class="headerlink" title="访问控制模型一"></a>访问控制模型一</h1><h2 id="访问控制的概念"><a href="#访问控制的概念" class="headerlink" title="访问控制的概念"></a>访问控制的概念</h2><ul>
<li><strong>访问控制</strong>，作为提供信息安全保障的主要手段，及最为突出的安全机制, 被广泛地应用于防火墙、文件访问、VPN及物理安全等多个方面。 所有这些技术可归诸于几类访问控制模型，本文将一一介绍并以实例说明，以帮助设计者在多变的环境中解决相关安全问题。</li>
<li><strong>访问控制</strong>是信息安全保障机制的核心内容，它是实现<strong>数据保密性</strong>和<strong>完整性</strong>机制的主要手段。</li>
<li><strong>访问控制</strong>是为了限制<strong>访问主体</strong>（或称为发起者，是一个主动的实体；如用户、进程、服务等），对<strong>访问客体</strong>（需要保护的资源）的访问权限，从而使计算机系统在合法范围内使用；</li>
<li><strong>访问控制</strong>机制决定用户及代表一定用户利益的程序能做什么，及做到什么程度。</li>
</ul>
<h3 id="访问控制的两个重要过程"><a href="#访问控制的两个重要过程" class="headerlink" title="访问控制的两个重要过程"></a>访问控制的两个重要过程</h3><ul>
<li>通过”鉴别（<code>authentication</code>）”来检验主体的合法身份</li>
<li>通过”授权（<code>authorization</code>）”来限制用户对资源的访问级别</li>
</ul>
<h3 id="访问行为"><a href="#访问行为" class="headerlink" title="访问行为"></a>访问行为</h3><ul>
<li>访问包括读取数据，更改数据，运行程序，发起连接等。</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>访问控制服务主要由<strong>访问控制模型</strong>和<strong>策略描述语言</strong>组成 </li>
<li>常见的访问控制模型主要是自主访问控制 <code>DAC</code>、强制访问控制 <code>MAC</code>、基于角色的访问控制 <code>RBAC</code>。 </li>
<li><strong>访问策略规则</strong>以及<strong>访问主体</strong>和<strong>访问客体</strong>三者是访问控制系统的基本条件。 </li>
<li><strong>访问主体</strong>：在信息环境中，对目标信息的获取通常是由访问主体发起的，访问主体需要遵循相应的规则，从而可以访问一定的客体。通常访问主体是用户开发和使用的应用程度。 </li>
<li><strong>访问客体</strong>：在信息系统中，客体可以被主体进行一定的访问行为操作。 </li>
<li><strong>安全访问策略</strong>：是为了保护信息安全性而制定的策略规则，规定了主体是否可以访问客体以及可以使用何种方式对客体进行访问。 </li>
<li>经典的三大模型<code>DAC</code>、<code>MAC</code>、<code>RBAC</code>，虽然现在在学术界这三大模型都遭到嫌弃，但是现有的访问控制模型其实都是在这三大模型上改改写写的。</li>
</ul>
<h2 id="自主访问控制（DAC-Discretionary-Access-Control）"><a href="#自主访问控制（DAC-Discretionary-Access-Control）" class="headerlink" title="自主访问控制（DAC,Discretionary Access Control）"></a>自主访问控制（DAC,Discretionary Access Control）</h2><ul>
<li>自主访问控制（<code>DAC</code>,<code>Discretionary Access Control</code>）比较基础和常用，在多种计算机系统中都会提供自主访问控制。</li>
<li>此种访问控制的基本思想是：访问控制中访问客体的拥有者具有很大的权限，能够决定客体是否可以被相应主体访问，并且可以迁移和转让访问客体。</li>
<li>在 <code>DAC</code> 模型中，访问权限是否进行授权需要根据主体情况并结合具体的安全规则从而做出判断。</li>
<li><code>DAC</code> 有<strong>访问控制矩阵</strong>和<strong>访问控制列表</strong>两种实施方式。 <h3 id="访问控制矩阵"><a href="#访问控制矩阵" class="headerlink" title="访问控制矩阵"></a>访问控制矩阵</h3>访问控制矩阵（<code>ACM</code>：<code>Acess Control Matrix</code>）中使用矩阵的列和行来分别对应访问主体和访问客体，二者交叉位置的元素则代表着相应的主体对客体的操作规则。<br><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525256809_605.png" alt=""><h3 id="访问控制列表"><a href="#访问控制列表" class="headerlink" title="访问控制列表"></a>访问控制列表</h3></li>
<li>访问控制列表（<code>ACL</code>：<code>Access Control List</code>）是前面说介绍矩阵的一种变形。</li>
<li>列表对应某个固定客体，其中的列表示能够对此客体进行一定操作的主体。</li>
<li>第二列访问属性则表示二者对应的具体操作。如表 所示，是上表中客体 X 所对应的等价控制矩阵转化。</li>
<li>通过 <code>ACL</code> 可以方便的理解和查询某个客体所对应的特定权限主体，适用于稳定的主客体不太复杂的系统。在信息系统发生较大改变时，需要重新对访问控制列表进行相应修改，容易影响系统安全性。</li>
</ul>
<p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525256836_10032.png" alt=""></p>
<p><code>DAC</code> 在进行授权时相对灵活，访问控制中客体的所有者可以将其所有用的权限进行转移，从而具有很好的灵活性，适用范围比较广，因而可以用于多个系统。但是，<code>DAC</code> 存在几个缺点：</p>
<ul>
<li>由于权限可以进行委托，会导致资源管理比较分散，同时增加了系统的风险性。 </li>
<li>不能够适应多域安全策略环境，以及在环境策略变化的情况下无法保证整体的安全性。 </li>
<li>访问控制权限容易发生转移，同时，在主体与客体数量较多时，会给系统带来巨大开销，导致效率低下，<strong>不能很好的适应交大规模的网络环境</strong>。</li>
</ul>
<h2 id="强制访问控制（MAC）"><a href="#强制访问控制（MAC）" class="headerlink" title="强制访问控制（MAC）"></a>强制访问控制（MAC）</h2><ul>
<li>强制访问控制（<code>MAC</code>：<code>Mandatory Acess Control</code>）在十八世纪七十年代就已经提出，在 <code>Multics</code> 模型上得到最早使用和验证，与前面介绍的自主访问控制相比，定义规则和策略相对更加严格。</li>
<li><code>MAC</code> 设计的基本思想是：在访问控制系统中，主体和客体被分配一定的安全属性，然后系统对二者所拥有的属性关系进行一定的评价比较，从而确定是否进行访问。</li>
<li>也就是说这是一种多级表示模型。比较关系来源于安全属性，并且用（安全级别，类型集合）这样的组合代表安全属性。</li>
<li>类型集合是指一定的元素的集体，而安全等级则表示相应信息的保密等级。在系统中安全属性是由维护系统的管理人员进行配置的，或者是系统自动生成的，这种安全属性是不能随意被修改的，具有强制认可性。 </li>
<li><code>MAC</code> 具有强制性和严格的单向不可逆性。</li>
<li><code>MAC</code> 系统规定高级别主体可以得到低级别主体的信息，而反过来却行不通。</li>
<li>如果主体<code>A</code> 的级别高于客体<code>B</code>，那么主体 <code>A</code> 可以读取客体<code>B</code> 中的信息和资源；如果主体 <code>A</code> 的级别低于主体 <code>B</code> 的级别，那么主体 <code>A</code> 可以对主体 <code>B</code> 进行一定的诸如写入的操作；如果主体 <code>A</code>和客体<code>B</code>的等级是相同的，那么主体<code>A</code> 和客体 <code>B</code> 之间不能进行任何读与写的操作。</li>
<li>这意味着在 <code>MAC</code> 模型的信息始终遵循单向流通的规则，因而可以保证系统信息的安全。如图 所示。</li>
</ul>
<p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525256893_20596.png" alt=""></p>
<p>强制访问控制中最具有代表性的就是 <code>BLP</code> 模型。</p>
<h2 id="基于角色的访问控制（RBAC）"><a href="#基于角色的访问控制（RBAC）" class="headerlink" title="基于角色的访问控制（RBAC）"></a>基于角色的访问控制（RBAC）</h2><ul>
<li>基于角色的访问控制（<code>RBAC</code>）是在上世纪九十年代被提出，是一种评估效果比较好的访问控制信息技。</li>
<li>在此种模型中，主体与客体并不是直接发生联系，而是增加了角色这一层次，先将访问操作的权限匹配给某些角色，然后在将这些特定的角色指定给相应的主体，通过这种方式主体就得到了对客体的访问权限。</li>
</ul>
<p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525256928_28770.png" alt=""></p>
<p>基于角色使得主体和客体之间的关系不是通过他们之间的映射来建立，而是中间有了周转，多了一个角色这个中转站。</p>
<h4 id="RBAC模型简介"><a href="#RBAC模型简介" class="headerlink" title="RBAC模型简介"></a>RBAC模型简介</h4><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525258602_21653.png" alt=""></p>
<ul>
<li>模型中主要定义了：用户(<code>User</code>)，角色(<code>Role</code>)和用户权限（<code>Permission</code>）三个主要实体，以及会话(<code>Session</code>)和限制(<code>Constraint</code>)的概念及其之间的关系。</li>
<li>其中，权限是指针对信息系统的操作权利，不同的角色或者不同级别的角色被赋予不同的权限，系统用户又被赋予一定的(一个或多个)角色。从而用户与角色之间，角色和权限之间均是一个多对多的<br>关系，用户和权限之间则没有直接的关系，而是根据所具有的责任被赋予某种角色，从而拥有角色相<br>应的权限。其授权模型示意图如上图所示。</li>
<li>在<code>RBAC</code>模型中，角色是一个相对的概念，用户与角色之间是多对多的关系，并且这一关系可以迅速变化，即用户所”扮演”的角色可以经常的发生变化；角色与权限之间也是多对多的关系，但是这一关系的变化则相对比较的缓慢，即角色拥有的权限是相对稳定。</li>
<li>会话集合中的每个黑点代表一个会话，它控制一个用户的多个角色，有效的控制角色之间的冲突。</li>
<li>即当一个被赋予多个角色的用户使用系统时，这些角色将分为属于若干个会话。</li>
<li>用户在任一时间内，只激活一个会话，从而用户在该时间类仅能扮演该激活会话中所包含的角色，其他角色在该段时间将为禁用。</li>
<li>使用<code>RBAC</code>模型能够通过用户授权(给用户指定角色)和角色授权(给角色分配操作权限)二个步骤实现完善的用户权限管理。<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2>然后随着云计算的出现，又出现了基于属性的访问控制<code>ABAC</code>，大家可以自行去查资料。基于属性的访问控制很厉害，它具有环境属性，而且可以把角色啊、客体啊、主体啊都当作一种属性，这种细粒度的访问控制安全性能很强，而且还能把数据挖掘的思想运用进来。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/Using-an-Access-Control-Matrix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/Using-an-Access-Control-Matrix/" itemprop="url">Using-an-Access-Control-Matrix</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T11:03:27+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Using-an-Access-Control-Matrix"><a href="#Using-an-Access-Control-Matrix" class="headerlink" title="Using_an_Access_Control_Matrix"></a>Using_an_Access_Control_Matrix</h1><p>使用访问控制模型<br><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525229245_8386.png" alt=""></p>
<h2 id="技术概念或主题（Concept-Topic-To-Teach）"><a href="#技术概念或主题（Concept-Topic-To-Teach）" class="headerlink" title="技术概念或主题（Concept / Topic To Teach）"></a>技术概念或主题（Concept / Topic To Teach）</h2><blockquote>
<p>In a role-based access control scheme, a role represents a set of access permissions and privileges. A user can be assigned one or more roles. A role-based access control scheme normally consists of two parts: role permission management and role assignment. A broken role-based access control scheme might allow a user to perform accesses that are not allowed by his/her assigned roles, or somehow allow privilege escalation to an unauthorized role.</p>
</blockquote>
<blockquote>
<p>在一个基于角色的访问控制方案中，角色代表了一组访问权限和特权。一个用户可以被<br>分配一个或多个角色。一个基于角色的访问控制方案通常有两个部分组成：角色权限管理和<br>角色分配。一个被破坏的基于角色的访问控制方案可能允许用户执行不允许他/她的被分配<br>的角色，或以某种方式允许特权升级到未经授权的角色的访问。</p>
</blockquote>
<h2 id="技术原理（How-It-works）"><a href="#技术原理（How-It-works）" class="headerlink" title="技术原理（How It works）"></a>技术原理（How It works）</h2><p>这个控制方案本身有缺陷</p>
<h2 id="总体目标（General-Goals）"><a href="#总体目标（General-Goals）" class="headerlink" title="总体目标（General Goals）"></a>总体目标（General Goals）</h2><blockquote>
<p>Each user is a member of a role that is allowed to access only certain resources. Your goal is to explore the access control rules that govern this site. Only the [Admin] group should have access to the ‘Account Manager’ resource.</p>
</blockquote>
<blockquote>
<p>每个用户都是角色的成员，每个角色只允许访问那些特定的资源。您的目标是浏览本站<br>管理所使用的访问控制规则。只有“Admin”组才能够访问“帐号管理”资源。</p>
</blockquote>
<h2 id="操作方法（Solutions）"><a href="#操作方法（Solutions）" class="headerlink" title="操作方法（Solutions）"></a>操作方法（Solutions）</h2><blockquote>
<p>This exercise is straightforward. You need to find a user where you can access a resource that you shouldn’t be able to access.</p>
</blockquote>
<p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/Access_Control_Flaws/_v_images/_1525229372_2326.png" alt=""></p>
<blockquote>
<p>After a few attempts you will learn that Larry can access resources of the role Account Manager.</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/HTTP请求报文/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/HTTP请求报文/" itemprop="url">HTTP请求报文</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T09:30:30+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h1><h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq= HTTP/1.1 </span><br><span class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, </span><br><span class="line">application/msword, application/x-silverlight, application/x-shockwave-flash, */* </span><br><span class="line">Referer: &lt;http://www.google.cn/&gt; </span><br><span class="line">Accept-Language: zh-cn </span><br><span class="line">Accept-Encoding: gzip, deflate </span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld) </span><br><span class="line">Host: [www.google.cn](http://www.google.cn/) </span><br><span class="line">Connection: Keep-Alive </span><br><span class="line">Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g;</span><br><span class="line">NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y- </span><br><span class="line">FxlRugatx63JLv7CWMD6UB_O_r</span><br></pre></td></tr></table></figure>
<p>观察发现，报文是用普通的<code>ASCII</code>文本书写。</p>
<p>其次，报文有很多行，每行用一个回车换行符结束。 </p>
<p>第一行：请求行（<code>request line</code>），</p>
<p>第一行后面的行，为请求头部（<code>header</code>）。 </p>
<p>然后是一个空行，最下面是请求数据。</p>
<p><img src="https://github.com/Anthem9/everyday/raw/master/image/593225-20151228140454010-1128568448.png" alt=""></p>
<p>###请求行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq= HTTP/1.1</span><br></pre></td></tr></table></figure>
<p><strong>有3个字段：方法字段，URL字段，HTTP协议版本字段。</strong> </p>
<ul>
<li>方法字段：<code>GET</code>, <code>POST</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code>。</li>
<li>当浏览器请求一个对象时，使用<code>GET</code>方法，在<code>URL</code>字段填写该对象的<code>URL</code>地址。 </li>
<li><code>HTTP</code>协议版本</li>
</ul>
<h4 id="1-GET"><a href="#1-GET" class="headerlink" title="1).GET"></a><strong>1).GET</strong></h4><p>最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是<code>GET</code>方式。<code>GET</code>方法要求服务器将<code>URL</code>定位的资源放在响应报文的数据部分，回送给客户端。使用<code>GET</code>方法时，请求参数和对应的值附加在<code>URL</code>后面，利用一个问号<code>?</code>代表<code>URL</code>的结尾与请求参数的开始，传递参数长度受限制。例如，<code>/index.jsp?id=100&amp;op=bind</code>,这样通过<code>GET</code>方式传递的数据直接表示在地址中，所以我们可以把请求结果以链接的形式发送给好友。以用<code>google</code>搜索<code>domety</code>为例，<code>Request</code>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq= HTTP/1.1  </span><br><span class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, </span><br><span class="line">application/msword, application/x-silverlight, application/x-shockwave-flash, */*  </span><br><span class="line">Referer: &lt;a href=&quot;http://www.google.cn/&quot;&gt;http://www.google.cn/&lt;/a&gt;  </span><br><span class="line">Accept-Language: zh-cn  </span><br><span class="line">Accept-Encoding: gzip, deflate  </span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  </span><br><span class="line">Host: &lt;a href=&quot;http://www.google.cn&quot;&gt;www.google.cn&lt;/a&gt;  </span><br><span class="line">Connection: Keep-Alive  </span><br><span class="line">Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; </span><br><span class="line">NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-</span><br><span class="line">FxlRugatx63JLv7CWMD6UB_O_r</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>GET</code>方式的请求一般不包含”请求内容”部分，请求数据以地址的形式表现在请求行。地址链接如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.google.cn/search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq=&quot;&gt;http://www.google.cn/search?hl=zh-CN&amp;source=hp</span><br><span class="line">&amp;q=domety&amp;aq=f&amp;oq=&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>地址中<code>?</code>之后的部分就是通过<code>GET</code>发送的请求数据，我们可以在地址栏中清楚的看到，各个数据之间用<code>&amp;</code>符号隔开。显然，这种方式不适合传送私密数据。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别<code>1024</code>个字符，所以如果需要传送大量数据的时候，也不适合使用<code>GET</code>方式。</p>
<h4 id="2-POST"><a href="#2-POST" class="headerlink" title="2).POST"></a>2).POST</h4><p>对于上面提到的不适合使用<code>GET</code>方式的情况，可以考虑使用<code>POST方</code>式，因为使用<code>POST</code>方法可以允许客户端给服务器提供较多信息。<code>POST</code>方法将请求参数封装在<code>HTTP</code>请求数据中，以<code>名称/值</code>的形式出现，可以传输大量数据，这样<code>POST</code>方式对传送的数据大小没有限制，而且也不会显示在<code>URL</code>中。还以上面的搜索<code>domety</code>为例，如果使用<code>POST</code>方式的话，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1  </span><br><span class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, </span><br><span class="line">application/msword, application/x-silverlight, application/x-shockwave-flash, */*  </span><br><span class="line">Referer: &lt;a href=&quot;http://www.google.cn/&quot;&gt;http://www.google.cn/&lt;/a&gt;  </span><br><span class="line">Accept-Language: zh-cn  </span><br><span class="line">Accept-Encoding: gzip, deflate  </span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  </span><br><span class="line">Host: &lt;a href=&quot;http://www.google.cn&quot;&gt;www.google.cn&lt;/a&gt;  </span><br><span class="line">Connection: Keep-Alive  </span><br><span class="line">Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; </span><br><span class="line">NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-</span><br><span class="line">FxlRugatx63JLv7CWMD6UB_O_r  </span><br><span class="line"></span><br><span class="line">hl=zh-CN&amp;source=hp&amp;q=domety</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>POST</code>方式请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用<code>&amp;</code>符号隔开。<code>POST</code>方式大多用于页面的表单中。因为<code>POST</code>也能完成<code>GET</code>的功能，因此多数人在设计表单的时候一律都使用<code>POST</code>方式，其实这是一个误区。<code>GET</code>方式也有自己的特点和优势，我们应该根据不同的情况来选择是使用<code>GET</code>还是使用<code>POST</code>。</p>
<h4 id="3-HEAD"><a href="#3-HEAD" class="headerlink" title="3).HEAD"></a><strong>3).HEAD</strong></h4><p><code>HEAD</code>就像<code>GET</code>，只不过服务端接受到<code>HEAD</code>请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用<code>HEAD</code>是非常高效的，因为在传输的过程中省去了页面内容。</p>
<h3 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h3><p>请求头部提供的信息是<code>WEB</code>代理缓存所要求的。</p>
<p>请求头部由<code>关键字/值</code>对组成，每行一对，关键字和值用英文冒号<code>:</code>分隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: &lt;a href=&quot;http://www.google.cn&quot;&gt;www.google.cn&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>定义了目标所在的主机。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>
<p>浏览器告诉服务器使用持久连接， <code>close</code> 则 使用非持久连接，即要求服务器在发送请求的对象后就关闭连接，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)</span><br></pre></td></tr></table></figure>
<p>定义用户代理，即向服务器发送请求的浏览器类型。<code>Mozilla/4.0</code>为<code>Netscape</code>浏览器。因此服务器可以正确地为不同类型的用户代理实际发送相同的对象不同的版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Language: zh-cn</span><br></pre></td></tr></table></figure>
<p>表示用户想得到该对象的语言版本,<strong>也可以作为用户地区的判断。</strong></p>
<p><strong>CLIENT-IP、X-FORWARDED-FOR、REMOTE_ADDR</strong></p>
<p>共同：后面加IP地址，<strong>可以用于服务端获取客户端的IP。</strong></p>
<p>区别：</p>
<ol>
<li><code>CLIENT-IP</code>头是有的，只是未成标准，不一定服务器都实现了。</li>
<li><code>X-FORWARDED-FOR</code> 是有标准定义，用来识别经过HTTP代理后的客户端IP地址，格式：<code>clientip</code>,<code>proxy1</code>,<code>proxy2</code>。可以被修改欺骗。</li>
<li><code>REMOTE-ADDR</code> 是可靠的， 它是最后一个跟你的服务器握手的<code>IP</code>，在<code>curl</code>中也无法伪造是，相对比较安全的服务端ip获取方法。</li>
</ol>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p>
<h3 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h3><p>请求数据不在<code>GET</code>方法中使用，而是在<code>POST</code>方法中使用。<code>POST</code>方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是<code>Content-Type</code>和<code>Content-Length</code>。</p>
<h2 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 31 Dec 2005 23:59:59 GMT</span><br><span class="line">Connection: Keep-Alive </span><br><span class="line">Content-Type: text/html;charset=ISO-8859-1</span><br><span class="line">Content-Length: 122</span><br><span class="line"></span><br><span class="line">＜html＞</span><br><span class="line">＜head＞</span><br><span class="line">＜title＞Wrox Homepage＜/title＞</span><br><span class="line">＜/head＞</span><br><span class="line">＜body＞</span><br><span class="line">＜!-- body goes here --＞</span><br><span class="line">＜/body＞</span><br><span class="line">＜/html＞1234567891011121314</span><br></pre></td></tr></table></figure>
<p><code>HTTP</code>响应也由三个部分组成，分别是：状态行、响应头部、空白行、响应实体。</p>
<p>如下所示，<code>HTTP</code>响应的格式与请求的格式十分类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">＜status-line＞</span><br><span class="line"></span><br><span class="line">＜headers＞</span><br><span class="line"></span><br><span class="line">＜blank line＞</span><br><span class="line"></span><br><span class="line">[＜response-body＞]</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Anthem9/everyday/raw/master/image/%E4%B8%8B%E8%BD%BD.png" alt=""></p>
<p> 正如你所见，在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息。状态行（<code>status line</code>）通过提供一个状态码来说明所请求的资源情况。</p>
<h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>状态行有3个字段：协议版本，状态码，相应状态信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>
<p>在这个例子中，状态行指示服务器使用的协议是<code>HTTP/1.1</code>，并且一切正常(服务器已找到并正在发送所请求的对象)</p>
<p>状态行格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP-Version Status-Code Reason-Phrase CRLF</span><br></pre></td></tr></table></figure>
<p>其中，<code>HTTP-Version</code>表示服务器HTTP协议的版本；<code>Status-Code</code>表示服务器发回的响应状态代码；<code>Reason-Phrase</code>表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。</p>
<ul>
<li>1xx：指示信息–表示请求已接收，继续处理。</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受。</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求。</li>
</ul>
<p>常见状态代码、状态描述的说明如下。</p>
<ul>
<li>200 OK：客户端请求成功。</li>
<li>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。</li>
<li>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</li>
<li>403 Forbidden：服务器收到请求，但是拒绝提供服务。</li>
<li>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</li>
<li>500 Internal Server Error：服务器发生不可预期的错误。</li>
<li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</li>
</ul>
<h3 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure>
<p>这个响应头部告诉客户机在报文发送完后关闭了该TCP连接。</p>
<ul>
<li><code>Date</code>：指示服务器产生并发送该相应报文的日期和时间。这个时间是服务器从他的文件系统中检索到该对象。插入到响应报文并发送响应报文的时间。 </li>
</ul>
<ul>
<li><code>Server</code>:表明该报文是由一个什么服务器产生的，类似于请求报文中的User-agent:请求头部 </li>
</ul>
<ul>
<li><code>Last-Modified</code>:表示对象创建会最后修改的日期和时间，这个首部行对可能在客户机也可能在网络缓存服务器上的对象缓存很重要。 </li>
<li><code>Content-Length</code>:表明被发送对象的字节数。 </li>
<li><code>Content-Type</code>:指示了实体主体中的对象时什么类型的文本如HTML文本，JSON对象文本</li>
</ul>
<h4 id="关于HTTP请求GET和POST的区别"><a href="#关于HTTP请求GET和POST的区别" class="headerlink" title="关于HTTP请求GET和POST的区别"></a><strong>关于HTTP请求GET和POST的区别</strong></h4><h5 id="1-区别"><a href="#1-区别" class="headerlink" title="1. 区别"></a>1. 区别</h5><p><code>GET</code>提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头<code>＜request-line＞</code>中），以<code>?</code>分割<code>URL</code>和传输数据，多个参数用&amp;连接;例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD</span><br></pre></td></tr></table></figure>
<p>如果数据是英文字母/数字，原样发送，如果是空格，转换为<code>+</code>，如果是中文/其他字符，则直接把字符串用<code>BASE64</code>加密，得出如： <code>%E4%BD%A0%E5%A5%BD</code>，其中<code>％XX</code>中的<code>XX</code>为该符号以<code>16进制</code>表示的<code>ASCII</code>。</p>
<p><code>POST</code>提交：把提交的数据放置在是<code>HTTP</code>包的包体<code>＜request-body＞</code>中。上文示例中红色字体标明的就是实际的传输数据</p>
<p>因此，<code>GET</code>提交的数据会在地址栏中显示出来，而<code>POST</code>提交，地址栏不会改变</p>
<h5 id="2-传输数据的大小："><a href="#2-传输数据的大小：" class="headerlink" title="2. 传输数据的大小："></a>2. 传输数据的大小：</h5><p>首先声明,<code>HTTP</code>协议没有对传输的数据大小进行限制，<code>HTTP</code>协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有：</p>
<p><code>GET</code>:特定浏览器和服务器对<code>URL</code>长度有限制，例如<code>IE</code>对<code>URL</code>长度的限制是2083字节(2K+35)。对于其他浏览器，如<code>Netscape</code>、<code>FireFox</code>等，理论上没有长度限制，其限制取决于操作系统的支持。</p>
<p>因此对于<code>GET</code>提交时，传输数据就会受到<code>URL</code>长度的限制。</p>
<p><code>POST</code>:由于不是通过<code>URL</code>传值，理论上数据不受限。但实际各个<code>WEB</code>服务器会规定对<code>post</code>提交数据大小进行限制，<code>Apache</code>、<code>IIS6</code>都有各自的配置。</p>
<h5 id="3-安全性："><a href="#3-安全性：" class="headerlink" title="3. 安全性："></a>3. 安全性：</h5><p>​    <code>POST</code>的安全性要比<code>GET</code>的安全性高。注意：这里所说的安全性和上面<code>GET</code>提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的<code>Security</code>的含义，比如：通过<code>GET</code>提交数据，用户名和密码将明文出现在<code>URL</code>上，因为<br>(1)登录页面有可能被浏览器缓存，<br>(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/WebGoat-General-HTTP-Basics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/WebGoat-General-HTTP-Basics/" itemprop="url">WebGoat_General_HTTP_Basics</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T09:03:41+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="WebGoat-HTTP-basics"><a href="#WebGoat-HTTP-basics" class="headerlink" title="WebGoat_HTTP_basics"></a>WebGoat_HTTP_basics</h1><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/WebGoat/_v_images/_1525221121_20356.png" alt=""></p>
<h2 id="技术概念或主题（Concept-Topic-To-Teach）"><a href="#技术概念或主题（Concept-Topic-To-Teach）" class="headerlink" title="技术概念或主题（Concept / Topic To Teach）"></a>技术概念或主题（Concept / Topic To Teach）</h2><p>This lesson presents the basics for understanding the transfer of data between the browser and the web application.</p>
<h2 id="技术原理（How-It-works）"><a href="#技术原理（How-It-works）" class="headerlink" title="技术原理（How It works）"></a>技术原理（How It works）</h2><p>Client Request: How HTTP works:</p>
<p>All HTTP transactions follow the same general format. Each client request and server response has three parts: <strong>the request or response line</strong>, <strong>a header section</strong>, and <strong>the entity body</strong>. The client initiates a transaction as follows: </p>
<p>The client contacts the server and sends a document request<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html?param=value HTTP/1.0</span><br></pre></td></tr></table></figure></p>
<p>Next, the client sends optional header information to inform the server of its configuration and the document formats it will accept.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/4.06 Accept: image/gif, image/jpeg, */*</span><br></pre></td></tr></table></figure></p>
<p>After sending the request and headers, the client may send additional data. This data is mostly used by CGI programs using the POST method.</p>
<h2 id="总体目标（General-Goals）"><a href="#总体目标（General-Goals）" class="headerlink" title="总体目标（General Goals）"></a>总体目标（General Goals）</h2><ul>
<li>Enter your name in the input field below and press “go” to submit. The server will accept the request, reverse the input, and display it back to the user, illustrating the basics of handling an HTTP request. </li>
<li>练习使用抓包工具<h2 id="操作方法（Solutions）"><a href="#操作方法（Solutions）" class="headerlink" title="操作方法（Solutions）"></a>操作方法（Solutions）</h2></li>
<li>设置浏览器代理，抓包，没啥好说的</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/WebGoat启程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/WebGoat启程/" itemprop="url">WebGoat启程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T06:33:43+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="WebGoat启程"><a href="#WebGoat启程" class="headerlink" title="WebGoat启程"></a>WebGoat启程</h1><h2 id="前言-amp-闲聊"><a href="#前言-amp-闲聊" class="headerlink" title="前言&amp;闲聊"></a>前言&amp;闲聊</h2><p>前几天给一个国外的留学生做他们的信息安全课程的作业，其中就有<code>WebGoat</code>的部分，感觉这个靶场很不错，于是决定来刷一波。</p>
<h2 id="WebGoat简介"><a href="#WebGoat简介" class="headerlink" title="WebGoat简介"></a>WebGoat简介</h2><blockquote>
<p><code>WebGoat</code>是一个用于讲解典型<code>web</code>漏洞的基于<code>J2EE</code>架构的<code>web</code>应用，他由著名的<code>WEB</code>应用安全研究组织<code>OWASP</code>精心设计并不断更新。<code>WebGoat</code>本身是一系列教程，其中设计了大量的<code>web</code>缺陷，一步步的指导用户如何去利用这些漏洞进行攻击，同时也指出了如何在程序设计和编码时避免这些漏洞。<code>Web</code>应用程序的设计者和测试者都可以在<code>WebGoat</code>中找到自己感兴趣的部分。虽然<code>WebGoat</code>中对于如何利用漏洞给出了大量的解释，但是还是比较有限，尤其是对于初学者来说，但觉得这正是其特色之处：<code>WebGoat</code>的每个教程都明确告诉你存在什么漏洞，但是如何去攻破要你自己去查阅资料，了解该漏洞的原理、特征和攻击方法，甚至要自己去找攻击辅助工具，当你成功时，<code>WebGoat</code>会给出一个红色的<code>Congratulation</code>，让你很有成就感！<br>[看雪论坛]</p>
</blockquote>
<h2 id="WebGoat部署"><a href="#WebGoat部署" class="headerlink" title="WebGoat部署"></a>WebGoat部署</h2><p>使用docker<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull webgoat/webgoat-<span class="number">7.1</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -p 8080:8080 -idt webgoat/webgoat-7.1</span></span><br></pre></td></tr></table></figure></p>
<p>打开<code>192.168.99.100:8080/WebGoat</code></p>
<h2 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h2><ul>
<li>Burp Suite</li>
<li>开发者工具</li>
</ul>
<hr>
<p>date: 2018-05-02 08:58:43</p>
<hr>
<h2 id="WriteUp格式"><a href="#WriteUp格式" class="headerlink" title="WriteUp格式"></a>WriteUp格式</h2><ul>
<li><p>一般来说直接复制英文的教程，其中一些跟教程不一样或者有些自己的理解的地方，会给出中文注释</p>
</li>
<li><p>不光是完成<code>WebGoat</code>的目标，大部分内容都会有相应的拓展。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/28/2018-4-28-周记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/28/2018-4-28-周记/" itemprop="url">2018.4.28 周记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-28T14:49:53+08:00">
                2018-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="打坐和念经"><a href="#打坐和念经" class="headerlink" title="打坐和念经"></a>打坐和念经</h1><h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h2><p>这个周总算是把Blog搞起来了，Blog的作用就是记录，记录一点一滴的成长，是督促也是奖励。</p>
<h2 id="日语"><a href="#日语" class="headerlink" title="日语"></a>日语</h2><p>还是想学日语，就在网上报了一个班，一个周六小时。希望能坚持下去。</p>
<h2 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h2><p>写这篇周记的时候正在打国赛，打不动跑来写周记了…太JB难了，为毛现在都是Web + PWN</p>
<p>趁WhaleCTF没开始下一期打卡赶紧把前面学的复习一遍</p>
<p>昨天做了一道PWN，感觉非常妙，我就是觉得CTF选手不应该局限在某一个方向，你看缓冲区溢出实际上跟SQL注入的原理是一样的，都是缺少对用户输入的校验。</p>
<h2 id="牙"><a href="#牙" class="headerlink" title="牙"></a>牙</h2><p>周一去种了牙，周二周三还难受，现在基本正常了。</p>
<p>买了一个电动牙刷和脱敏牙膏，医生说还要用牙线，我还没买，再说吧。</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>接到了第一份和我专业相关的工作，是给一个国外的留学生写作业，这个留学生应该也是信息安全专业的，他们的作业真的是好棒，通过模拟实战进行渗透练习，用的也是著名的Web靶场WebGoat和一个TCP软件VulnServer。还没做之前就感觉做完肯定能学到东西，结果也确实是这样，不过作业毕竟是作业，WebGoat这个靶场还没有被完全利用，我想（Flag）抽时间把WebGoat刷完。复习完WhaleCTF再学习VulnServer。</p>
<p>寻找资料的过程发现很多资料都使用了Metasploit，神器真的要好好学习一下。</p>
<p>还有为了大洋彼岸的这位仁兄做作业，强迫自己读了大量英语文献，虽然比较痛苦，有些只能不停的去查Google，但是确实感觉英语水平有了提升，看着满篇英语舒服一点了…这算抖M嘛…</p>
<h2 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h2><p>马上就要微积分大物离散数学的期中考试了，数学实验什么的…我当初就不应该选，有了Python还用什么Matlab。</p>
<p>5.1假期就老老实实复习吧，毕竟大物一节课都没听。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>上面是流水账，下面正文开始~</p>
<p>首先是遇到了一个有趣的女生，但是我觉得要请奶茶不太容易。2333333</p>
<p>但是心中是有了一种安心的感觉，不知道为什么，我不想去想，不想去解释，就这样，挺好。</p>
<p>很美妙，她有魔力能让我浮躁的心静下来，安心的做事，专注的做事。我猛然醒悟，这正是我现在最欠缺的东西，眼高手低，心浮气躁已经开始影响我的心智，怪不得ESR说黑客喜欢参禅和习武，并且注重“道“的领悟，我初看时还疑惑，纳闷外国人怎么还好这些虚无的东西。但现在我觉得，佛教的打坐念经，道教的入定，武功的悟道，瑜伽的冥想，心理学里的催眠术，这些似乎都是通过引导，清空人内心的杂念，从而使人能够更加专注的工作和学习。算是磨刀不误砍柴工。</p>
<p>或许可以尝试一下。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/26/Docker安装文本编辑器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/26/Docker安装文本编辑器/" itemprop="url">Docker安装文本编辑器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-26T19:37:20+08:00">
                2018-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Docker安装文本编辑器"><a href="#Docker安装文本编辑器" class="headerlink" title="Docker安装文本编辑器"></a>Docker安装文本编辑器</h1><p>在使用<code>docker</code>容器时，有时候里边没有安装<code>vim</code>，敲<code>vim</code>命令时提示说：<code>vim: command not found</code>，这个时候就需要安装<code>vim</code>，可是当你敲<code>apt-get install vim</code>命令时，提示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Reading package lists... Done </span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done </span><br><span class="line">E: Unable to locate package vim</span><br></pre></td></tr></table></figure></p>
<p>这时候需要敲：<code>apt-get update</code>，这个命令的作用是：同步 <code>/etc/apt/sources.list</code> 和 <code>/etc/apt/sources.list.d</code> 中列出的源的索引，这样才能获取到最新的软件包。 </p>
<p>等更新完毕以后再敲命令：<code>apt-get install vim</code>命令即可。</p>
<p>注：<code>apt-get install vi</code>也是找不到的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/26/Linux-find命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/26/Linux-find命令/" itemprop="url">Linux-find命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-26T19:28:26+08:00">
                2018-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h1><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li><p>列出当前目录及子目录下所有文件和文件夹</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find .</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>/home</code>目录下查找以<code>.txt</code>结尾的文件名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -name <span class="string">"*.txt"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同上，但忽略大小写</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -iname <span class="string">"*.txt"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意，虽然<code>name</code>是一个完整的单词，但前面只有一条横线</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/26/进入docker容器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/26/进入docker容器/" itemprop="url">进入docker容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-26T19:25:16+08:00">
                2018-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="进入docker容器"><a href="#进入docker容器" class="headerlink" title="进入docker容器"></a>进入docker容器</h1><p>进入<code>Docker</code>容器比较常见的几种做法如下：</p>
<ul>
<li>使用<code>docker attach</code></li>
<li>使用<code>docker exec</code></li>
</ul>
<h2 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- -d, --detach=<span class="literal">false</span> Run container <span class="keyword">in</span> background and <span class="built_in">print</span> container ID</span><br></pre></td></tr></table></figure>
<p>如果要<code>attach</code>交互使用，考虑</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-i, --interactive=<span class="literal">false</span> Keep STDIN open even <span class="keyword">if</span> not attached</span><br><span class="line">-t, --tty=<span class="literal">false</span> Allocate a pseudo-TTY</span><br></pre></td></tr></table></figure>
<h2 id="使用docker-attach"><a href="#使用docker-attach" class="headerlink" title="使用docker attach"></a>使用docker attach</h2><ul>
<li><p><code>Docker</code>提供了<code>attach</code>命令来进入<code>Docker</code>容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker attach --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage:  docker attach [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">Attach <span class="built_in">local</span> standard input, output, and error streams to a running container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --detach-keys string   Override the key sequence <span class="keyword">for</span> detaching a</span><br><span class="line">                             container</span><br><span class="line">      --no-stdin             Do not attach STDIN</span><br><span class="line">      --sig-proxy            Proxy all received signals to the process</span><br><span class="line">                             (default <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>先创建一个守护态（后台运行）的<code>Docker</code>容器，就是加<code>-itd</code>参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 8080:8080 -itd webgoat/webgoat-7.1</span><br><span class="line">a951769562560aa3c9e214347a96c5dc2676bf3ed06773fc5b8e3d617042519e</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后使用<code>docker ps</code>查看到该容器信息，复制<code>CONTAINER ID</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">ca41f316c698        webgoat/webgoat-7.1   <span class="string">"java -Djava.securit…"</span>   10 hours ago        Up 10 hours         0.0.0.0:8080-&gt;8080/tcp   cranky_almeida</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后使用<code>docker attach</code>进入该容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker attach ca41f316c698</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后你就会发现卡住了…</p>
<h3 id="为什么执行-docker-attach-卡住了"><a href="#为什么执行-docker-attach-卡住了" class="headerlink" title="为什么执行 docker attach 卡住了?"></a>为什么执行 docker attach 卡住了?</h3><p>首先要明确的是 <code>docker attach</code>不是一个用来进入容器的命令, 或者说他不是用来在容器内运行一个 <code>bash(shell)</code>的命令, 它是用来连接到容器中运行中的进程, 也就是容器的 <code>CMD</code>, 容器内 <code>PID=1</code> 的那个进程, 如果这个进程没有 <code>stdout/stderr</code> 那么你将看不到任何输出, 如果它没有接收<code>stdin</code>你也无法发送指令给它. 这也就是为什么你运行一个<code>bash</code> 的容器, 就可以 <code>attach</code> 进去执行命令, 而你运行一个<code>mysql server</code> 的容器就无法操作的原因</p>
</li>
</ul>
<h2 id="使用docker-exec"><a href="#使用docker-exec" class="headerlink" title="使用docker exec"></a>使用docker exec</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage:  docker <span class="built_in">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...]</span><br><span class="line"></span><br><span class="line">Run a <span class="built_in">command</span> <span class="keyword">in</span> a running container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -d, --detach               Detached mode: run <span class="built_in">command</span> <span class="keyword">in</span> the background</span><br><span class="line">      --detach-keys string   Override the key sequence <span class="keyword">for</span> detaching a</span><br><span class="line">                             container</span><br><span class="line">  -e, --env list             Set environment variables</span><br><span class="line">  -i, --interactive          Keep STDIN open even <span class="keyword">if</span> not attached</span><br><span class="line">      --privileged           Give extended privileges to the <span class="built_in">command</span></span><br><span class="line">  -t, --tty                  Allocate a pseudo-TTY</span><br><span class="line">  -u, --user string          Username or UID (format:</span><br><span class="line">                             &lt;name|uid&gt;[:&lt;group|gid&gt;])</span><br><span class="line">  -w, --workdir string       Working directory inside the container</span><br></pre></td></tr></table></figure>
<ul>
<li><p>查看容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">ca41f316c698        webgoat/webgoat-7.1   <span class="string">"java -Djava.securit…"</span>   10 hours ago        Up 10 hours         0.0.0.0:8080-&gt;8080/tcp   cranky_almeida</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>docker exec</code>进入该容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it ca41f316c698 /bin/bash</span><br><span class="line">root@ca41f316c698:/<span class="comment">#</span></span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/25/Docker入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/25/Docker入门/" itemprop="url">Docker入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-25T21:15:08+08:00">
                2018-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Docker入门"><a href="#Docker入门" class="headerlink" title="Docker入门"></a>Docker入门</h1><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/Docker/_v_images/_1524657822_18293.png" alt=""></p>
<h2 id="起因-amp-amp-闲聊"><a href="#起因-amp-amp-闲聊" class="headerlink" title="起因&amp;&amp;闲聊"></a>起因&amp;&amp;闲聊</h2><p>学习<code>Docker</code>的起因是这样的，星辰<code>DevOps</code>组的学长转发了一个广告，那人说要解决一个问题，是安全方向的，然后我面试的时候说过自己对安全有兴趣，结果学长就让我去试试。</p>
<p>去了一问，结果是一个国外留学生的信息安全作业，其中<code>Part2</code>正好是<code>Web</code>方向，是要用<code>WebGoat</code>学习<code>Web</code>漏洞，我寻思正好啊，既能学东西又有钱赚，就接了。</p>
<p>好嘛，直接打开<code>WebGoat</code>的<code>Github</code>，<code>README</code>里第一个介绍的就是使用<code>Docker</code>进行环境安装。</p>
<p>我对是<code>Docker</code>仰慕已久了，但一直没敢动手去学，心道干脆借这个机会学了算了，就这样开始了我的<code>Docker</code>学习之路。</p>
<h2 id="初识Docker"><a href="#初识Docker" class="headerlink" title="初识Docker"></a>初识Docker</h2><h3 id="环境配置的难题"><a href="#环境配置的难题" class="headerlink" title="环境配置的难题"></a>环境配置的难题</h3><p>软件开发的时候最大的麻烦事就是环境配置。我用<code>Python</code>写<code>Flask</code>的时候就被这个烦的不行，<code>Linux</code>自带的<code>Python</code>环境是<code>2.7</code>的，也是我的错，我没用虚拟环境直接安装了<code>Python3.4</code>，结果导致<code>Flask</code>找库的时候各种找不到，每次运行服务总有各种各样的玄学问题，实在是把我折磨疯了。</p>
<p>除了版本问题，还有环境变量，一般来说，我们在开发过程中需要使用邮箱密码，数据库密码等敏感信息来使用这些服务，有些程序员直接把这些信息写在代码里，但这样做是不安全的（<code>Github</code>上很多这样的泄露，造成很大隐患），比较安全的做法是把这些数据保存在环境变量里，然后在代码中引用环境变量，但这又会带来迁移的麻烦。但<code>Docker</code>解决了这个问题，环境变量也一起打包好了。</p>
<p>简单来说，<code>Docker</code>就是为了防止开发人员在一台又一台的机器上重复恼人的环境配置而开发的。</p>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>肯定有人会提到虚拟机，虚拟机也是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统。而运行在虚拟机里的应用程序对此是无感知的，因为虚拟机看上去跟真实系统一模一样。而对于底层操作系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p>
<p>虽然用户可以通过虚拟机还原软件的原始环境，但是，这个方案有几个缺点：</p>
<ul>
<li>资源占用多</li>
<li>冗余步骤多<br>如操作系统的用户登录等</li>
<li>启动慢</li>
</ul>
<h3 id="Linux容器"><a href="#Linux容器" class="headerlink" title="Linux容器"></a>Linux容器</h3><p>由于虚拟机存在这些缺点，<code>Linux</code> 发展出了另一种虚拟化技术：<code>Linux</code> 容器（<code>Linux Containers</code>，缩写为<code>LXC</code>）。</p>
<p><code>Linux</code> 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p>
<p>由于容器是进程级别的，相比虚拟机有很多优势。</p>
<ul>
<li><p>启动快<br>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p>
</li>
<li><p>资源占用少<br>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p>
</li>
<li><p>体积小<br>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p>
</li>
</ul>
<p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p>
<h3 id="Docker是什么？"><a href="#Docker是什么？" class="headerlink" title="Docker是什么？"></a>Docker是什么？</h3><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 <code>Linux</code> 容器解决方案。</p>
<p><code>Docker</code> 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 <code>Docker</code>，就不用担心环境问题。</p>
<p>总体来说，<code>Docker</code>的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>
<h3 id="Docker的用途"><a href="#Docker的用途" class="headerlink" title="Docker的用途"></a>Docker的用途</h3><p><code>Docke</code>r 的主要用途，目前有三大类。</p>
<ul>
<li><p><strong>提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p>
</li>
<li><p><strong>提供弹性的云服务。</strong>因为 <code>Docker</code>容器可以随开随关，很适合动态扩容和缩容。</p>
</li>
<li><p><strong>组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p>
</li>
</ul>
<p>这里我搭建<code>WebGoat</code>就是其第一个用途。</p>
<h3 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h3><p>我的系统是<code>windows10 家庭版</code> 不是<code>Pro</code> 没有<code>Hyper-V</code>的安装，所以在家庭版中安装<code>Docker</code>必须使用<code>Docker Toolbox</code>来安装。<br><code>Docker Toolbox</code><a href="https://www.docker.com/products/docker-toolbox" target="_blank" rel="noopener">下载地址</a>，选择<code>Windows</code>版本，点击下载即可。<br>下载完成后，双击<code>DockerToolbox.exe</code>进行安装，一路<code>next</code>就可以，</p>
<p>看到安装了<code>Vbox</code>和<code>Git Bash</code>想来是要模拟<code>Linux</code>环境了，<code>Windows</code>果然麻烦的一匹。</p>
<p>完成后会有下图三个图标</p>
<p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/Docker/_v_images/_1524659633_18828.png" alt=""></p>
<p>双击<code>Docker Quickstart Terminal</code>，会提示错误，如图：</p>
<p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/Docker/_v_images/_1524659666_12661.png" alt=""></p>
<p>这时，点击浏览，找到<code>git</code>安装目录下的<code>bin</code>目录，选择<code>bin</code>目录下的<code>bash.exe</code>文件，点击确定，<code>Docker</code>开始初始化。</p>
<p>初始化过程中如果下载<code>boot2docker.iso</code>没反应，可以直接从<code>GitHub</code><a href="https://github.com/boot2docker/boot2docker/releases/download/v18.04.0-ce/boot2docker.iso" target="_blank" rel="noopener">下载</a>，直接复制到那个文件里</p>
<p>成功后界面如下图：<br><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/Docker/_v_images/_1524659700_7710.png" alt=""><br>到此成功在<code>Windows 10</code>中安装<code>Docker</code>，但是每次启动都需要手动选择<code>bash.exe</code>文件。</p>
<p>其他操作系统的安装请参考<a href="https://docs.docker.com/" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="一把梭"><a href="#一把梭" class="headerlink" title="一把梭"></a>一把梭</h2><p><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/Docker/_v_images/_1524660237_24106.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull webgoat/webgoat-7.1</span><br><span class="line">docker run -p 8080:8080 -t webgoat/webgoat-7.1</span><br></pre></td></tr></table></figure></p>
<p><code>pull</code>完就<code>run</code>很美妙对不对？<br>可是它为啥卡在这不动…<br>醒醒吧，你在天朝啊！天朝无所不有，你怎么能用外国的源呢？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.docker-cn.com/webgoat/webgoat-7.1</span><br><span class="line">docker run -p 8080:8080 -t webgoat/webgoat-7.1</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>Docker</code> 中国官方镜像加速可通过 <code>registry.docker-cn.com</code> 访问。该镜像库只包含流行的公有镜像。私有镜像仍需要从美国镜像库中拉取。</li>
<li>实测挂了全局的<code>ss</code>代理好像还是不能直接用国外的源，惆怅。</li>
<li>永久配置请参考<a href="https://www.docker-cn.com/registry-mirror" target="_blank" rel="noopener">官方文档</a></li>
</ul>
<h3 id="Docker容器的IP"><a href="#Docker容器的IP" class="headerlink" title="Docker容器的IP"></a>Docker容器的IP</h3><p>当你运行<code>Docker</code>的时候，注意这个地方<br><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/Docker/_v_images/_1524660762_29280.png" alt=""><br>这就是这个容器的<code>IP</code></p>
<p>当你运行<code>WebGoat</code>的时候，不要被它骗了<br><img src="https://github.com/Anthem9/vnote/raw/master/vnotebook/Docker/_v_images/_1524660894_17757.png" alt=""><br>不管它怎么在<code>localhost</code>欢迎你去<code>hacking</code>，你要记得去访问上面哪个<code>IP</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.99.100:8080/WebGoat</span><br></pre></td></tr></table></figure></p>
<p>因为它的<code>localhost</code>是虚拟容器的<code>localhost</code>不是你的<code>localhost</code></p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>期间等待过程中还<code>Standalone</code>安装了一下，虽然步骤简单，但打开服务发现有少量乱码，很难受。也不知道怎么解决。</p>
<p>但使用<code>Docker</code>安装好就没有这个问题，很妙。</p>
<p>至此，第一次使用<code>Docker</code>的坑记录完毕！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
